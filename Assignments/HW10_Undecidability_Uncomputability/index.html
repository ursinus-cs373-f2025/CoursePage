<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<!-- Header !-->
	<head>
		<title>Ursinus CS 373: Theory of Computation, Fall 2023</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<!--[if lte IE 8]><script src="../../assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="../../assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="../../assets/css/ie8.css" /><![endif]-->
        <style>
        .image_off, #home:hover .image_on{
           display:none
        }
        .image_on, #home:hover .image_off{
           display:block
        }
        </style>
	</head>
	<body>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../../index.html" class="logo"><strong>Ursinus CS 373: Theory of Computation, Fall 2023</strong></a>
								</header>
<!-- End Header !-->

							<!-- Content -->
								<section>
									<header class="main">
                                        <h2>Homework 10: Undecidability And Uncomputability (17 Points)</h2>
										<h3>Chris Tralie</h3>
									</header>

									<div id="page-content">

                                        <h2>Overview / Logistics</h2>
										<p>
                                            In this homework we'll explore some limits of computation: in particular, languages that are at the edge of decidability and functions that are at the edge of computability.
                                        </p>

										<p>
											There are no JFLAP problems on this homework.  You should submit a single typed document with the answers to each question.  You can use Microsoft Word, LaTeX, or anything else you're comfortable with.
										</p>
										
										<HR>
											<h3>Problem 1 (3 Points)</h3>

											<p>
												Consider the language <b>L</b> of turing machines <b>M</b> that have the property that if <b>M</b> accepts <b>w</b>, then <b>M</b> also accepts the reverse <b>w<SUP>R</SUP></b>.  Show that <b>L</b> is undecidable
											</p>

											<p>
												<b>Hint: </b> You can use a very similar trick to the proof <a href = "../../ClassExercises/Week12_Undecidability/index.html#etm"> that <b>E<SUB>TM</SUB></b> is undecidable</a>; that is, create an auxiliary machine that you can show could be used to decide <b>A<SUB>TM</SUB></b> if you feed it to a decider for <b>L</b>.  Alternatively, you can argue that the conditions for <a href = "../../ClassExercises/Week12_Undecidability/index.html#rice">Rice's theorem</a> are fulfilled.
											</p>

										<HR>
											<h3>Problem 2 (3 Points)</h3>

											<p>
												Define a <b>useless state</b> in a Turing machine as a state that is never reached on any possible input to the machine.  It would be nice to detect and remove these states for a more parsimonious Turing machine.  Unfortunately, the language
											</p>

											<h3>
												L<SUB>U</SUB> = { &lt;M, q&gt; | q is a useless state in M}
											</h3>

											<p>
												is undecidable.  Prove this by contradiction by showing that L<SUB>U</SUB> can be used to decide <b>E<SUB>TM</SUB></b>.
											</p>

										<HR>
											<h3>Problem 3 (3 Points)</h3>
											<p>
												We'll explore something called the <b>Collatz conjecture</b> in this problem.  This is a seemingly innocuous math problem that's very easy to state, but it has served as a "black hole" that has sucked in many an aspiring mathematician, because it still eludes a proof after almost a century from when it was first posed.  The conjecture is as follows: given the following piecewise function
											</p>

											<div style="width:200px;">
												<h3>
													\[ f(x) = \left\{ \begin{array}{cc} 3x + 1 & x \text{ is odd} \\ x/2 & x \text{ is even} \end{array} \right\} \]
												</h3>
											</div>

											<p>
												It is thought that it is always possible to iterate this function and end up at a 1, starting <b>at any natural number</b>.  Take the following examples, which all end at a 1 (in fact, it's been exhaustively verified that every natural number up to <b>2<SUP>68</SUP></b> eventually ends up at 1)
											</p>

											<iframe src="collatz.html" width=800 height=400></iframe>
												
												

											<p>
												Hence, the problem is sometimes referred to as the "3x + 1" problem
											</p>



											</p>
												The author of this <a href = "https://www.quantamagazine.org/why-mathematicians-still-cant-solve-the-collatz-conjecture-20200922/">popular math article on the conjecture</a> recommends that we <i>do not try to solve this math problem.</i>.  However, let's cheat for a moment and suppose that <b>Halt<SUB>TM</SUB></b> is decidable.  Provide a high level description of a machine that outputs whether the Collatz conjecture is true or not, using this hypothetical decidable <b>Halt<SUB>TM</SUB></b> oracle to help you.
											</p>

											<p>
												<b>Hint: </b>  To nail this, you'll have to use <b>Halt<SUB>TM</SUB></b> more than once!
											</p>
										


											<HR>
												<h3>Problem 4 (5 Points)</h3>

												<p>
													We're going to think about some <b>very</b> large numbers now.  Consider a function over the natural numbers known as the <b>Busy Beaver Function BB(N)</b>, whose output value at <b>N</b> is the maximum number of steps<SUP><a href = "#shift">[1]</a></SUP> that any Turing machine of a special form with <b>N</b> states can take before halting, <b>if it halts</b>.  The Turing machines used in the Busy Beavers have the following properties

													<h5><a name = "bbformat">Busy Beaver Format</a></h5>
													<ul>
														<li>
															The tape alphabet <b>&Gamma;</b> is {0, 1}
														</li>
														<li>The tape starts off with all 0's stretching to infinity on the right and left side (there is otherwise no input)</li>
														<li>The machine can only move <b>left</b> or <b>right</b> (there is no stay)</li>
														<li>
															There is a single accept state that <i>does not count towards the <b>N</b> states that are used.</i>
														</li>
													</ul>

													<i><SUP><a name = "shift">[1]</a></SUP> Technically I'm referring here to something called the "Rad√≥ shift function," but it's related and makes our proofs slightly easier</i>

													<P></P>
													

													<ol>
														<li>
															<p>
															<b>(1 Point)</b> What input/output pair of the Busy Beaver function can you bound from below by the following Turing machine?  What value is the lower bound?	(This value actually turns out to achieve the maximum for this number of states)
															</p>

															<img src = "BB3.png">


															<p>
																<a href = "BB3.jff">Click here</a> to download the JFLAP file, which you can use to help answer this question.  Note that JFLAP does not have the capability to start the tape with all 0s, so blanks are treated as 0s in this machine and are redundant with all of the 0 rules.
															</p>

															
	
														</li>

														<li>
															<b>(2 Points)</b> A function from the natural numbers to the natural numbers is <b>computable</b> if, starting with the input to the function, the machine halts with just the output to the function on the tape. <b>Prove that the busy beaver function is not computable</b>, supposing by contradiction that it is computable and using it as a subroutine to decide something undecidable.
														</li>

														<li>
															<b>(2 Points)</b> Suppose for a moment that the halting problem is decidable.  Then, it would be theoretically possible to compute <b>BB(N)</b> by the following very slow but simple algorithm
															
															<ul>
																<li>Start BB(N) at 0</li>
																<li>For each machine <b>M</b> with <b>N</b> states in <a href = "#bbformat">busy beaver format</a>
																<ul>
																	<li>
																		If <b>M</b> halts, run <b>M</b> and record the number of steps <b>s</b> that it takes.  If <b>s &gt; BB(N)</b>, then update <b>BB(N)</b> to be <b>s</b>
																	</li>
																</ul>
																</li>
															</ul>
															
															How many Turing machines would you have to check in the outer loop for <b>BB(N)</b>?

															<P>
																<b>Hint: </b> How many possible arrows can you draw when you're at a particular state and you see a <b>0</b>?  How about if you see a <b>1</b>?  How would you multiply these possibilities across all states?  (Go back and think about the <a href = "https://brilliant.org/wiki/fundamental-counting-principle/">fundamental counting principle</a> if you're rusty)
															</P>
														</li>


													</ol>


													
													
												</p>
											<HR>
											<h3>Problem 5 (3 Points)</h3>					
												<p>
													The busy beaver function grows <b>very quickly</b>.  In fact, <b>BB(18)</b> already exceeds <a href = "https://en.wikipedia.org/wiki/Graham%27s_number">Graham's number</a>, one of the biggest numbers ever used in mathematical research (check out <a href = "https://www.youtube.com/watch?v=HX8bihEe3nA">this video</a>, <a href = "https://www.youtube.com/watch?v=txajrEOTkuY">this video</a>, and <a href = "https://www.youtube.com/watch?v=GuigptwlVHo">this video</a>).  But we can show something even stronger and more general about the busy beaver's asymptotic growth.  Let <b>f</b> be <i>any computable function</i> over natural numbers expressed in binary.  Prove that there exists and <b>N<SUB>c</SUB></b> so that <b>BB(N) > f(N)</b> for all <b>N > N<SUB>c</SUB></b>.
												</p>

												<p>
													<b>Hint: </b> Since <b>f</b> is computable, you can devise a Turing machine for it.  Suppose this Turing machine has <b>C</b> states, which is a constant independent of <b>N</b>.  Now fix <b>N</b> and consider how you would devise a machine in <a href = "#bbformat">busy beaver format</a> to compute <b>f(N)</b> and then to take a number of steps at least as long as this.  <b>How many states does this machine have, in terms of <b>C</b> and <b>N</b></b>? 

													
												</p>

												<p>
													<b>Hint within hint(!):</b> Since the busy beaver machine starts off with a tape of all 0's, you have to use state memory to load in the input <b>N</b> to <b>f(N)</b>.
												</p>
												
                                    
                                </div>
						</div>
					</div>

					<!--LaTeX in Javascript!-->
					<script src="../../../../jsMath/easy/load.js"></script>
					<!--Syntax highlighting in Javascript!-->
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shCore.js"></script>
					<script type="text/javascript" src="../../../syntaxhighlighter/scripts/shBrushJScript.js"></script>
                    <script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushCpp.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushXml.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushMatlabSimple.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushPython.js"></script>
					<link type="text/css" rel="stylesheet" href="../../../../syntaxhighlighter/styles/shCoreDefault.css"/>
					<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">
							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<h2>Menu</h2>
									</header>
									<ul>
                                        <li>
											<span class="opener">General</span>
											<ul>
												<li><a href = "../../index.html#overview">Overview</a></li>
												<li><a href = "../../index.html#logistics">Technology Logistics</a></li>
												<li><a href = "../../index.html#readings">Readings</a></li>
												<li><a href = "../../index.html#deliverables">Deliverables</a></li>
												<li><a href = "../../index.html#schedule">Schedule</a></li>
												<li><a href = "../../index.html#grading">Grading</a></li>
												<li><a href = "../../index.html#environment">Classroom Environment</a></li>
												<li><a href = "../../index.html#collaboration">Collaboration Policy</a></li>
												<li><a href = "../../index.html#other">Other Resources / Policies</a></li>
											</ul> 
										</li>
										<li><a href = "../../Software/index.html">Software</a></li>
										<li><a href = "../../index.html#schedule">Schedule</a></li>
										<li><a href = "../../FinalProject/index.html">Final Project</a></li>
                                        <li>
											<span class="opener">Assignments</span>
											<ul>
												<li>
													<a href = "../../Assignments/HW1_Discrete/index.html">HW1: Discrete Math Practice</a>
												</li>
												<li>
													<a href = "../../Assignments/HW2_DFA/index.html">HW2: DFAs</a>
												</li>
												<li>
													<a href = "../../Assignments/HW3_NFA/index.html">HW3: DFAs And NFAs</a>
												</li>
												<!--
												<li>
													<a href = "../../Assignments/HW4_Regexp/index.html">HW4: (Non)Regular Languages And Regular Expressions</a>
												</li>
												<li>
													<a href = "../../Assignments/HW5_CFGs/index.html">HW5: Context Free Grammars</a>
												</li>
												<li>
													<a href = "../../Assignments/HW6_PDAs/index.html">HW6: Pushdown Automata</a>
												</li>
												<li>
													<a href = "../../Assignments/HW7_Turing/index.html">HW7: Turing Machines</a>
												</li>
												<li>
													<a href = "../../Assignments/HW8_Turing2/index.html">HW8: Turing Machines Part 2</a>
												</li>
												<li>
													<a href = "../../Assignments/HW9_Decidability/index.html">HW9: Decidability</a>
												</li>
												<li>
													<a href = "../../Assignments/HW10_Undecidability_Uncomputability/index.html">HW10: Undecidability And Uncomputability</a>
												</li>!-->
											</ul>
										</li>
                                        <li>
											<span class="opener">Class Exercises</span>
											<ul>
												<li><a href = "../../ClassExercises/Week1_Unplugged">Week 1: Acting Out DFAs</a></li>
												<li><a href = "../../ClassExercises/Week1_Discrete">Week 1: Discrete Math Review</a></li>
												<li><a href = "../../ClassExercises/Week1_FridayDFABinary">Week 1: Binary And JFLAP</a>
													<ul>
														<li><a href = "../../ClassExercises/Week1_FridayDFABinary/index.html#binary">Binary Drills</a></li>
														<li><a href = "../../ClassExercises/Week1_FridayDFABinary/index.html#jflap">JFLAP Exercises</a></li>
													</ul>
												</li>
												<li><a href = "../../ClassExercises/Week2_Formal">Week 2: Formal Description of DFAs, Divisibility</a>
													<ul>
														<li>
															<a href = "../../ClassExercises/Week2_Formal/index.html#formalcode">Formal Regular Languages: Code</a>
														</li>
													</ul>
												</li>
												<li><a href = "../../ClassExercises/Week2_Union">Week 2: Union of Regular Languages</a></li>
												<li><a href = "../../ClassExercises/Week3_NFAs">Week 3: Nondeterministic Finite Automata (NFAs), Reversing Regular Languages</a></li>
												<li><a href = "../../ClassExercises/Week3_NFAToDFA">Week 3: NFAs Recognize Regular Languages (i.e. NFAs To DFAS)</a></li>
												<li><a href = "../../ClassExercises/Week4_NFACode">Week 4: Efficiently Evaluating NFAs in Python with and without Lambda</a></li>
												<li><a href = "../../ClassExercises/Week4_DFAToRegexp">Week 4: Converting Regular Expressions To DFAs And Back</a></li>
												<li><a href = "../../ClassExercises/Week5_PumpingLemma">Week 5: The Pumping Lemma</a></li>
												<li><a href = "../../ClassExercises/Week7_Turing">Week 7/8: Turing Machine Examples</a></li>
												<li><a href = "../../ClassExercises/Week8_MultitapeTuring">Week 8: Multitape Turing Machine Examples</a></li>
												<li><a href = "../../ClassExercises/Week10_Decidability">Week 10: Decidability</a></li>
												<li><a href = "../../ClassExercises/Week11_Infinities">Week 11: Countable And Uncountable Infinities</a></li>
												<li><a href = "../../ClassExercises/Week12_Undecidability">Week 12: Undecidability</a></li>
											</ul>
										</li>
									</ul>
								</nav>


							<!-- Footer -->
								<footer id="footer">
									<p class="copyright">&copy; <a href = "http://www.ctralie.com">Christopher J. Tralie</a>. All rights reserved.  Contact chris.tralie@gmail.com. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
								</footer>

						</div>
					</div>

			</div>
			
            <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- End Sidebar !-->

<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/skel.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="../../assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="../../assets/js/main.js"></script>
<!-- End Scripts -->
