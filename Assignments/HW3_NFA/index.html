<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<!-- Header !-->
	<head>
		<title>Ursinus CS 373: Theory of Computation, Fall 2025</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<!--[if lte IE 8]><script src="../../assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="../../assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="../../assets/css/ie8.css" /><![endif]-->
        <style>
        .image_off, #home:hover .image_on{
           display:none
        }
        .image_on, #home:hover .image_off{
           display:block
        }
        </style>
	</head>
	<body>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../../index.html" class="logo"><strong>Ursinus CS 373: Theory of Computation, Fall 2025</strong></a>
								</header>
<!-- End Header !-->

							<!-- Content -->
								<section>
									<header class="main">
                                        <h2>Homework 3: NFAs And DFAs (26 Points)</h2>
										<h3><a href = "http://www.ctralie.com">Chris Tralie</a></h3>
									</header>

									<div id="page-content">

                                        <h2>Overview / Logistics</h2>
										
										<p>
                                            The purpose of this problem set is to give you practice with NFAs and their interplay with DFAs.  At the heart of what we're doing is the idea that if we've done the hard work to design DFAs to recognize some language(s), we can do a little more work to treat them as modules and to combine them in clever ways to make DFAs that recognize other languages.  Sometimes an NFA will help as an intermediate step.
										</p>
										<p>
											For all problems that require you to construct an NFA or a DFA, <b>you should submit a JFLAP file</b>.  For all other problems, submit a picture of pen + paper work or a PDF document of a writeup.  Enjoy!
                                        </p>

										<!--<b>(Q, &Sigma;, &delta;, q, F)</b>!-->

										<h3>Problem 1: The Union of Regular Languages (3 Points)</h3>
										<p>
											Design a DFA that recognizes strings that are divisible by 3 <b>OR</b> divisible by 4.  Then, design an NFA that also recognizes this language
										</p>

										<p>
											Below are some tests you can try in JFLAP (<a href = "tests1.txt">Click here</a> to download them)
										</p>

										<table style="width:200px;"><tr><td>Decimal Number</td><td>Input</td><td>Result</td></tr>
											<tr><td> 44 </td><td> 101100 </td><td> Accept </td></tr>
											<tr><td> 47 </td><td> 101111 </td><td> Reject </td></tr>
											<tr><td> 64 </td><td> 1000000 </td><td> Accept </td></tr>
											<tr><td> 67 </td><td> 1000011 </td><td> Reject </td></tr>
											<tr><td> 67 </td><td> 1000011 </td><td> Reject </td></tr>
											<tr><td> 9 </td><td> 1001 </td><td> Accept </td></tr>
											<tr><td> 83 </td><td> 1010011 </td><td> Reject </td></tr>
											<tr><td> 21 </td><td> 10101 </td><td> Accept </td></tr>
											<tr><td> 36 </td><td> 100100 </td><td> Accept </td></tr>
											<tr><td> 87 </td><td> 1010111 </td><td> Accept </td></tr>
											</table>
																					
											

										<h3>Problem 2: The Intersection of Regular Languages (3 Points)</h3>
										<p>
											Prove by construction that regular languages are closed under intersection
										</p>

										<p>
											<b>Hint:</b> You can do a similar construction to the proof that regular languages are closed under union, but all you need to change is the accept state
										</p>

										<h3>Problem 3: NFA Design (3 Points)</h3>
										<p>
											Design an NFA that recognizes the language of odd binary numbers that have a 1 in the 32s place, when read <i>from left to right</i>.
										</p>

										<p>
											Below are some tests you can try in JFLAP (<a href = "tests3.txt">Click here</a> to download them)
										</p>
										<p>
											<table style="width:200px;"><tr><td>Decimal Number</td><td>Input</td><td>Result</td></tr>
												<tr><td> 99 </td><td> 1100011 </td><td> Accept </td></tr>
												<tr><td> 206 </td><td> 11001110 </td><td> Reject </td></tr>
												<tr><td> 239 </td><td> 11101111 </td><td> Accept </td></tr>
												<tr><td> 189 </td><td> 10111101 </td><td> Accept </td></tr>
												<tr><td> 230 </td><td> 11100110 </td><td> Reject </td></tr>
												<tr><td> 118 </td><td> 1110110 </td><td> Reject </td></tr>
												<tr><td> 144 </td><td> 10010000 </td><td> Reject </td></tr>
												<tr><td> 73 </td><td> 1001001 </td><td> Reject </td></tr>
												<tr><td> 8 </td><td> 1000 </td><td> Reject </td></tr>
												<tr><td> 228 </td><td> 11100100 </td><td> Reject </td></tr>
											</table>
												
										</p>

										<h3>Problem 4: The Complement of Regular Languages (3 Points)</h3>
										<p>
											We've seen some examples where swapping the accept and non-accept states of a DFA that recognizes a language <b>L</b> over the alphabet &Sigma; yields a DFA which recognizes the <b>complement</b> of <b>L</b>; that is, all strings made up of characters from &Sigma; that are <b>not</b> in L.  For instance, the machine below accepts binary strings that contain 1010 somewhere (<a href = "Contains1010.jff">Click here</a> for the JFLAP file)
										</p>
										<img src = "Contains1010.png">
										<p>
											and the machine below accepts binary strings that <b>do not</b> contain 1010 (<a href = "NotContains1010.jff">Click here</a> for the JFLAP file)
										</p>
										<img src = "NotContains1010.png">

										<p>
											Does this same property hold for NFAs?  If so, provide a proof in general.  If not, show a counter-example (an example where this is not true), along with the inputs that break it.
										</p>

										<h3>Problem 5: The Union And Concatenation of Regular Languages (3 Points)</h3>
										<p>
											Create an NFA that recognizes the the language of strings with a nonzero and even number of a's or with a nonzero and even number of bs, followed by one or more bs, followed by an odd number of a's or an odd number of b's.
										</p>

										<p>
											Below are some tests you can try in JFLAP (<a href = "tests5.txt">Click here</a> to download them).  If you don't agree on a particular test case, take advantage of JFLAP's NFA branch explorer by trying that test out with <code>Input->Step By State</code>
										</p>

										<table style="width:200px;"><tr><td>Input</td><td>Result</td></tr>
											<tr><td>aaaab</td><td>Reject</td></tr>
											<tr><td>bbaabbb</td><td>Accept</td></tr>
											<tr><td>bbaabaa</td><td>Reject</td></tr>
											<tr><td>aabbbb</td><td>Accept</td></tr>
											<tr><td>ababab</td><td>Accept</td></tr>
											<tr><td>abab</td><td>Reject</td></tr>
											<tr><td>ababb</td><td>Accept</td></tr>
											<tr><td>aaaba</td><td>Reject</td></tr>
											<tr><td>bbb</td><td>Reject</td></tr>
											<tr><td>bbbb</td><td>Accept</td></tr>
											<tr><td>bbbbbbbbbbbbbb</td><td>Accept</td></tr>
											<tr><td>aaaaaaaaaaa</td><td>Reject</td></tr>
											<tr><td>bbbaabb</td><td>Accept</td></tr>
										</table>

										<p>
											Let's highlight a couple of the accept strings to show how they get split up
										</p>

										<h4>Example 1: ababab</h4>
										<p>
											We can split this up as follows
										</p>
										<table style="width:500px;">
											<tr>
												<td>A <b>nonzero and even number of a's</b> or with a nonzero and even number of bs</td>
												<td>
													One or more bs
												</td>
												<td>
													An <b>odd number of a's</b> or an <b>odd number of b's</b>
												</td>
											</tr>
											<tr>
												<td>aba</td>
												<td>b</td>
												<td>ab</td>
											</tr>
										</table>

										<h4>Example 2: ababb</h4>

										<table style="width:500px;">
											<tr>
												<td>A <b>nonzero and even number of a's</b> or with a nonzero and even number of bs</td>
												<td>
													One or more bs
												</td>
												<td>
													An odd number of a's or an <b>odd number of b's</b>
												</td>
											</tr>
											<tr>
												<td>aba</td>
												<td>b</td>
												<td>b</td>
											</tr>
										</table>


										<h4>Example 3: bbbbbbbb</h4>

										<p>
											There are a bunch of ways to split this one up.  
										</p>

										<table style="width:500px;">
											<tr>
												<td>A nonzero and even number of a's or with a <b>nonzero and even number of bs</b></td>
												<td>
													One or more bs
												</td>
												<td>
													An odd number of a's or an <b>odd number of b's</b>
												</td>
											</tr>
											<tr>
												<td>bb</td>
												<td>bbb</td>
												<td>bbb</td>
											</tr>
											<tr>
												<td>bbbb</td>
												<td>b</td>
												<td>bbb</td>
											</tr>
											<tr>
												<td>bb</td>
												<td>bbbbb</td>
												<td>b</td>
											</tr>
										</table>

										


										<h3>Problem 6: The Reverse of Regular Languages Part 1 (3 Points)</h3>
										<p>
											Prove <b>using a DFA</b> that if a binary string is divisible by 3, then its reverse is also divisible by 3.
										</p>

										<h3>Problem 7: The Reverse of Regular Languages Part 2 (3 Points)</h3>
										<p>
											If a binary string is divisible by 6, then its reverse is not necessarily divisible by 6.  For instance, the string 1100 (12) is divisible by 6, but its reverse 0011 (3) is not divisible by 6.  Construct a DFA that recognize the language of binary strings whose reverse is divisible by 6.  These strings should be inputted <i>from right to left</i>.
										</p>

										<p>
											<b>Hint:</b> First construct and test an NFA that recognizes this language, then convert this to a DFA using the technique we described in class.  If you've only expanded the states you needed to expand, the DFA should have even fewer states than the one that recognizes strings divisible by 6!
										</p>

										<p>
											Below are some tests you can try in JFLAP (<a href = "tests7.txt">Click here</a> to download them)
										</p>

										<table style="width:200px;"><tr><td>Input</td><td>Decimal Number</td><td>Reverse Binary</td><td>Reverse Decimal</td><td>Result</td></tr>
											<tr><td><b> 1010111 </b></td><td> 87 </td><td> 1110101 </td><td> 117 </td><td><b> Reject </b></td></tr>
											<tr><td><b> 00100001 </b></td><td> 33 </td><td> 10000100 </td><td> 132 </td><td><b> Accept </b></td></tr>
											<tr><td><b> 001101 </b></td><td> 13 </td><td> 101100 </td><td> 44 </td><td><b> Reject </b></td></tr>
											<tr><td><b> 00000011 </b></td><td> 3 </td><td> 11000000 </td><td> 192 </td><td><b> Accept </b></td></tr>
											<tr><td><b> 0010011 </b></td><td> 19 </td><td> 1100100 </td><td> 100 </td><td><b> Reject </b></td></tr>
											<tr><td><b> 0110011 </b></td><td> 51 </td><td> 1100110 </td><td> 102 </td><td><b> Accept </b></td></tr>
											<tr><td><b> 01101111 </b></td><td> 111 </td><td> 11110110 </td><td> 246 </td><td><b> Accept </b></td></tr>
											<tr><td><b> 11010111 </b></td><td> 215 </td><td> 11101011 </td><td> 235 </td><td><b> Reject </b></td></tr>
											<tr><td><b> 0010101 </b></td><td> 21 </td><td> 1010100 </td><td> 84 </td><td><b> Accept </b></td></tr>
											<tr><td><b> 00010001 </b></td><td> 17 </td><td> 10001000 </td><td> 136 </td><td><b> Reject </b></td></tr>
										</table>
											
											

																					
											
										<h3><a name = "substring">Problem 8: DFAs for Substring Search (5 Points)</a></h3>
										
										<p>
											We're going to examine an application of DFAs that's used all the time behind the scenes in text editors and web browsers.  Consider the following problem: given a string <code>pattern</code> and a string <code>s</code>, determine if <code>pattern</code> is a substring (contiguous subset) of <code>s</code>.  One way to do this is to check every possible subset of length <code>len(pattern)</code> in <code>s</code>.  The code below shows how one might do this in python:
										</p>

										<script type="syntaxhighlighter" class="brush: python"><![CDATA[
											def naive_substring_search(pattern, s):
												"""
												Implement the naive O(len(pattern) * len(s)) algorithm for finding
												all instances of pattern in s

												Parameters
												----------
												pattern: string
													Search pattern
												s: string
													String in which to search for pattern
												
												Returns
												-------
												list of int:
													A list of all of the indices at which pattern exists in s
												"""
												instances = []
												for i in range(len(s)-len(pattern)+1):
													j = 0
													valid = True
													while valid and j < len(pattern):
														if pattern[j] == s[i+j]:
															j += 1 # Continue along as long as we do match
														else:
															valid = False # Break out early as soon as we don't match
													if valid:
														instances.append(i)
												return instances
										</script>  

										<p>
											So, for instance, if we run
											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												naive_substring_search("ababac", "abababcabababcababacababac")	
												#
											</script>  

										</p>
											
											
										<p>
											We should get <code>[14, 20]</code> (zero-indexed), since the pattern shows up twice at the end.  However, our algorithm goes quite slow on this because there are many times where it <i>almost</i> matches the pattern, but then it has to start over.  In the worst case, this algorithm can take <code>len(pattern)*len(s)</code> steps, so we say it's a <b>O(len(pattern)*len(s))</b> algorithm (we will talk about big-O notation later in the course).
										</p>
										<p>
											As it turns out, we can construct a DFA for substring that only has to go through each character in the string <i>exactly once</i>, and we report a match every time it reaches an accept state.  Hence, the algorithm only takes <b>O(len(s))</b> time, which can be substantially better in practice if <code>pattern</code> is long.  For instance, consider the following DFA (<a href = "ababac.jff">Click here</a> to download the JFLAP file)
										</p>
										<img src = "ababac.png">
										<p>
											Now let's step through and search for our pattern:
										</p>
										<img src = "ababac.gif">
										<p>
											You'll notice that we reached the accept state exactly twice at the end of each instance of <code>pattern</code> in <code>s</code>.  But how on earth did we come up with this?  Here is a fairly straightforward algorithm to do this:
										</p>

										<h4><a name = "alg1">Algorithm 1: Straightforward Substring DFA Creation</a></h4>
										
										<iframe width="560" height="315" src="https://www.youtube.com/embed/gmV-LPNC-_g?si=4Ma8LYsyz5_M-pLC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

										<ol>
											<li>
												Create a state <code>start</code> and a state <code>c_i</code> for each character <code>c</code> in the pattern at index <code>i</code>.  For instance, if the pattern is <code>acdc</code>, you should have the states 
												<ul>
													<li>
														<code>start</code>
													</li>
													<li>
														<code>a_0</code>
													</li>
													<li>
														<code>c_1</code>
													</li>
													<li>
														<code>d_2</code>
													</li>
													<li>
														<code>c_3</code>
													</li>
												</ul>
											</li>
											<li>
												<p>
													Add state transitions for the matched characters in sequence.  For instance, in the <code>acdc</code> pattern, we'd have a transition from <code>start</code> to <code>a_0</code> when we see an <code>a</code>, a transition from <code>a_0</code> to <code>c_1</code> when we see a <code>c</code>, etc.
												</p>
												<p>
													Also, in a separate loop, add the remaining arrows from start back to itself for all other characters in the alphabet.  In <code>acdc</code>, assuming an alphabet of <code>{a, b, c, d}</code>, we'd add the arrows from b, c, and d from start to itself.
												</p>
											</li>
											<li>
												Loop through each character in the pattern in sequence.  For each character <code>c</code> at index <code>i</code>, loop through all characters <code>a</code> in the alphabet <code>Sigma</code>.  

												<ul>
													<li>
														If an arrow doesn't exist yet at <code>c<SUB>i</SUB></code> using <code>a</code>, 
														<ul>
															<li>
																Then the <i>first</i> <code>i+1</code> characters of <code>pattern</code> do not match the string where we are ending at <code>a</code>
															</li>
															<li>
																However, it is possible that the <i>last</i> <code>i</code> characters of the string match the first <code>i</code> characters of the pattern, or that the last <code>i-1</code> characters of the pattern match the first <code>i-1</code> characters of the pattern, etc.
															</li>.
															To figure out how much of the pattern we've actually matched, send <code>a</code> concatenated to the last <code>i</code> characters of pattern (<code>pattern[1:i+1]+a</code> in python) through the DFA that you've built so far, and use the state that you end on as the transition out of <code>c<SUB>i</SUB></code> through <b>a</b>
														</ul> 
													</li>
												</ul>

											</li>
										</ol>

										<h4>
											Your task
										</h4>
										<p>
											<a href = "https://github.com/ursinus-cs373-f2023/CoursePage/blob/main/Assignments/HW3_NFA/substring.py">Click here</a> to download the starter code for this task.
										</p>

										<p>
											Create a python method <code>make_substring_dfa(Sigma, pattern)</code> that takes in an alphabet as a list in <code>Sigma</code> and a <code>pattern</code> string, and which returns a <code>delta</code> dictionary describing the DFA transitions that match <code>pattern</code>.  For example, if you run the following code:
										</p>

										So, for instance, if you run
											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												Sigma = ['a', 'b', 'c']
												pattern = "ababac"
												delta = make_substring_dfa(Sigma, "ababac")
												for key, value in delta.items():
													print(key, ":", value)
												write_dfa_jflap(delta, "ababac.jff")

											</script>  
											
										then your program should output the above example.  It will also print the values of the dictionary, which you can check individually.  They should look like this on the above example, in no particular order:
										<script type="syntaxhighlighter" class="brush: python"><![CDATA[
											('start', 'a') : a_0
											('start', 'b') : start
											('start', 'c') : start
											('a_0', 'b') : b_1
											('b_1', 'a') : a_2
											('a_2', 'b') : b_3
											('b_3', 'a') : a_4
											('a_4', 'c') : c_5
											('a_0', 'a') : a_0
											('a_0', 'c') : start
											('b_1', 'b') : start
											('b_1', 'c') : start
											('a_2', 'a') : a_0
											('a_2', 'c') : start
											('b_3', 'b') : start
											('b_3', 'c') : start
											('a_4', 'a') : a_0
											('a_4', 'b') : b_3
											('c_5', 'a') : a_0
											('c_5', 'b') : start
											('c_5', 'c') : start

										</script>  




										<h4>Hint</h4>
										<p>
											The following code will create the strings representing the states for each character <code>c</code> at index <code>i</code>
										</p>
										<script type="syntaxhighlighter" class="brush: python"><![CDATA[
											ci = "{}_{}".format(c, i)
											#
										</script> 

										<h4>Hint 2</h4>
										<p>
											If you're having trouble figuring out where to get started, at least see if you can do step 1 in <a href = "#alg1">the algorithm</a>, then save the DFA and look at it in JFLAP to see if you have the right states.  Then try step 2 and see if you have the arrows for matching characters.  Finally, you can tackle the third step, which is the hardest
										</p>

										<h4>Extra Credit (+2)</h4>
										<p>
											The DFA that you've built is very efficient and can find all instances of the pattern in <b>O(len(s))</b> time, which is substantially better than the <b>O(len(s)*len(pattern))</b> algorithm we started with.  However, <a href = "#alg1">algorithm 1</a> for <i>constructing</i> the DFA is not very efficient, and is in fact <code>O(len(alphabet)*len(pattern)<SUP>2</SUP>)</code>, assuming a constant alphabet size, which is quite bad for long patterns.  Luckily, there is a variation that we can do known as the <b>Knuth-Morris-Pratt</b> algorithm to accomplish DFA construction with all arrows in <code>O(len(alphabet)*len(pattern))</code> time only.  Implement this algorithm to construct your DFA instead of the one described in <a href = "#alg1">algorithm 1</a>.  <a href = "https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/#">Click here</a> to view some notes about this on GeeksForGeeks.
										</p>

										<p>
											<b>NOTE: </b> In practice, the KMP algorithm doesn't actually store arrows for every character in the alphabet coming out of each state; it only tells you where to jump if there's about to be a mismatch, before you process the next character.  This is more efficient to do in practice, because it scales well for large alphabets.  What I'm looking for in the extra credit, though, is to create <b>all arrows</b> using a similar trick to what KMP does.  In particular, you'll want to track the longest suffix of the string you're searching that's still a prefix of the pattern you're matching, rather than checking the entire suffix minus one character like we've been doing.</b>
										</p>


										<!--
										<h3>Problem 8: Ordered Mixing of Regular Languages (3 Points)</h3>
										<p>
											Define an <b>ordered mixing</b> of two regular languages <b>A</b> and <b>B</b> over the alphabet <b>&Sigma;</b> to be the set of all strings <b>s</b> so that 
										</p>

										<div style="width:200px;">
											<h3>
												\[ s = a_1b_1a_2b_2 ... a_kb_k \]
											</h3>

											where the string 

											<h3>
												\[ a_1a_2 ... a_k \in A \]
											</h3>

											and the string

											<h3>
												\[ b_1b_2 ... b_k \in B \]
											</h3>

										</div>
										<p>
											and each <b>a<SUB>k</SUB>, b<SUB>k</SUB></b> is a <i>chunk</i> of a string; formally
										</p>
										<div style="width:200px;">


											<h3>
												\[ a_k, b_k \in \Sigma^* \]
											</h3>

										</div>

										<p>
											For instance, suppose that we have the string <span style="color:blue">computerscience</span> in the first language and the string <span style="color: red">philosophy</span> in the second language.  Then here are a few ordered mixings we can create from just these two words:
										</p>
										<ul>
											<li> <span style="color:blue">c</span><span style="color:red">ph</span><span style="color:blue">o</span><span style="color:red">il</span><span style="color:blue">mp</span><span style="color:red">oso</span><span style="color:blue">u</span><span style="color:red">phy</span><span style="color:blue"></span><span style="color:blue"></span><span style="color:blue"></span><span style="color:blue">te</span><span style="color:blue">r</span><span style="color:blue">sc</span><span style="color:blue">ien</span><span style="color:blue">ce</span> </li>
											<li> <span style="color:blue">com</span><span style="color:red">p</span><span style="color:blue">pu</span><span style="color:red">hi</span><span style="color:blue">te</span><span style="color:red">lo</span><span style="color:blue">r</span><span style="color:red">so</span><span style="color:blue">s</span><span style="color:red">p</span><span style="color:blue">ci</span><span style="color:red">hy</span><span style="color:blue">enc</span><span style="color:blue">e</span> </li>
											<li> <span style="color:blue">c</span><span style="color:red">phi</span><span style="color:blue">o</span><span style="color:red">lo</span><span style="color:blue">mp</span><span style="color:red">sop</span><span style="color:blue">u</span><span style="color:red">hy</span><span style="color:blue">t</span><span style="color:blue">e</span><span style="color:blue">rsc</span><span style="color:blue"></span><span style="color:blue">ien</span><span style="color:blue">ce</span> </li>
											<li> <span style="color:blue">c</span><span style="color:red">phi</span><span style="color:blue">omp</span><span style="color:red">l</span><span style="color:blue">ute</span><span style="color:red">o</span><span style="color:blue">r</span><span style="color:red">s</span><span style="color:blue">sc</span><span style="color:red">op</span><span style="color:blue">ien</span><span style="color:red">h</span><span style="color:blue">c</span><span style="color:red">y</span><span style="color:blue">e</span> </li>
											<li> <span style="color:blue">c</span><span style="color:red">ph</span><span style="color:blue">omp</span><span style="color:red">ilo</span><span style="color:blue">u</span><span style="color:red">so</span><span style="color:blue">te</span><span style="color:red">ph</span><span style="color:blue">rs</span><span style="color:red">y</span><span style="color:blue">cie</span><span style="color:blue">nce</span> </li>
										</ul>

										<p>
											Your task in this problem is to prove by construction that an ordered mixing of two regular languages is a regular language.
										</p>
										<p>
											<b>Hint #1: </b> You should consider making cartesian product states so you can keep track of where you are in each string that you're mixing
										</p>
										<p>
											<b>Hint #2: </b> It may be easier to first think about how to make a DFA to recognize a simpler type of mixing where each chunk is a single character.  Then see if you can extend this idea with an NFA to define a full ordered mixing
										</p>
										-->
										

                                    
                                </div>
						</div>
					</div>

					<!--LaTeX in Javascript!-->
					<script src="../../../../jsMath/easy/load.js"></script>
					<!--Syntax highlighting in Javascript!-->
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shCore.js"></script>
					<script type="text/javascript" src="../../../syntaxhighlighter/scripts/shBrushJScript.js"></script>
                    <script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushCpp.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushXml.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushMatlabSimple.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushPython.js"></script>
					<link type="text/css" rel="stylesheet" href="../../../../syntaxhighlighter/styles/shCoreDefault.css"/>
					<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">
							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<h2>Menu</h2>
									</header>
									<ul>
                                        <li>
											<span class="opener">General</span>
											<ul>
												<li><a href = "../../index.html#overview">Overview</a></li>
												<li><a href = "../../index.html#logistics">Technology Logistics</a></li>
												<li><a href = "../../index.html#readings">Readings</a></li>
												<li><a href = "../../index.html#deliverables">Deliverables</a></li>
												<li><a href = "../../index.html#schedule">Schedule</a></li>
												<li><a href = "../../index.html#grading">Grading</a></li>
												<li><a href = "../../index.html#environment">Classroom Environment</a></li>
												<li><a href = "../../index.html#collaboration">Collaboration Policy</a></li>
												<li><a href = "../../index.html#other">Other Resources / Policies</a></li>
											</ul> 
										</li>
										<li><a href = "../../Software/index.html">Software</a></li>
										<li><a href = "../../index.html#schedule">Schedule</a></li>
										<li><a href = "../../FinalProject/index.html">Final Project</a></li>
                                        <li>
											<span class="opener">Assignments</span>
											<ul>
												<li>
													<a href = "../../Assignments/HW1_Discrete/index.html">HW1: Discrete Math Practice</a>
												</li>
												<li>
													<a href = "../../Assignments/HW2_DFA/index.html">HW2: DFAs</a>
												</li>
												<li>
													<a href = "../../Assignments/HW3_NFA/index.html">HW3: DFAs And NFAs</a>
												</li>
												<li>
													<a href = "../../Assignments/HW4_Regexp/index.html">HW4: Regular Expressions And Nonregular Languages</a>
												</li>
												<li>
													<a href = "../../Assignments/HW5_CFGs/index.html">HW5: Context Free Grammars And Pushdown Automata</a>
												</li>
												<li>
													<a href = "../../Assignments/HW6_Turing/index.html">HW6: Turing Machines</a>
												</li>
												<li>
													<a href = "../../Assignments/HW7_Turing2/index.html">HW7: Turing Machines, Turing Enumerators, And Decidability</a>
												</li>
												<li>
													<a href = "../../Assignments/HW8_Decidability/index.html">HW8: Decidability</a>
												</li>
												<li>
													<a href = "../../Assignments/HW9_Computability/index.html">HW9: Computability</a>
												</li>
											</ul>
										</li>
                                        <li>
											<span class="opener">Class Exercises</span>
											<ul>
												<li><a href = "../../ClassExercises/Week1_Unplugged">Week 1: Acting Out DFAs</a></li>
												<li><a href = "../../ClassExercises/Week1_Discrete">Week 1: Discrete Math Review</a></li>
												<li><a href = "../../ClassExercises/Week1_FridayDFABinary">Week 1: Binary And JFLAP</a>
													<ul>
														<li><a href = "../../ClassExercises/Week1_FridayDFABinary/index.html#binary">Binary Drills</a></li>
														<li><a href = "../../ClassExercises/Week1_FridayDFABinary/index.html#jflap">JFLAP Exercises</a></li>
													</ul>
												</li>
												<li><a href = "../../ClassExercises/Week2_Formal">Week 2: Formal Description of DFAs, Divisibility</a>
													<ul>
														<li>
															<a href = "../../ClassExercises/Week2_Formal/index.html#formalcode">Formal Regular Languages: Code</a>
														</li>
													</ul>
												</li>
												<li><a href = "../../ClassExercises/Week2_Union">Week 2: Union of Regular Languages</a></li>
												<li><a href = "../../ClassExercises/Week3_NFAs">Week 3: Nondeterministic Finite Automata (NFAs), Reversing Regular Languages</a></li>
												<li><a href = "../../ClassExercises/Week3_NFAToDFA">Week 3: NFAs Recognize Regular Languages (i.e. NFAs To DFAS)</a></li>
												<li><a href = "../../ClassExercises/Week4_NFACode">Week 4: Efficiently Evaluating NFAs in Python with and without Lambda</a></li>
												<li><a href = "../../ClassExercises/Week4_DFAToRegexp">Week 4: Converting Regular Expressions To DFAs And Back</a></li>
												<li><a href = "../../ClassExercises/Week4_Grep">Week 4: Grep: Regular Expression Parsing And Evaluating</a></li>
												<li><a href = "../../ClassExercises/Week5_PumpingLemma">Week 5: The Pumping Lemma</a></li>
												<li><a href = "../../ClassExercises/Week7_Turing">Week 7/8: Turing Machine Examples</a></li>
												<li><a href = "../../ClassExercises/Week8_MultitapeTuring">Week 8: Multitape Turing Machine Examples</a></li>
												<li><a href = "../../ClassExercises/Week10_Decidability">Week 10: Decidability</a></li>
												<li><a href = "../../ClassExercises/Week11_Infinities">Week 11: Countable And Uncountable Infinities</a></li>
												<li><a href = "../../ClassExercises/Week12_Undecidability">Week 12: Undecidability</a></li>
												<li><a href = "../../ClassExercises/Week13_Modules/video1.html">Week 13: The Class P</a></li>
												<li><a href = "../../ClassExercises/Week13_Modules/video2.html">Week 13: The Class NP</a></li>
												<li><a href = "../../ClassExercises/Week14_CookLevin">Week 14: Cook Levin Theorem And SAT Solving</a></li>
											</ul>
										</li>
									</ul>
								</nav>


							<!-- Footer -->
								<footer id="footer">
									<p class="copyright">&copy; <a href = "http://www.ctralie.com">Christopher J. Tralie</a>. All rights reserved.  Contact chris.tralie@gmail.com. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
								</footer>

						</div>
					</div>

			</div>
			
            <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- End Sidebar !-->

<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/skel.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="../../assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="../../assets/js/main.js"></script>
<!-- End Scripts -->
