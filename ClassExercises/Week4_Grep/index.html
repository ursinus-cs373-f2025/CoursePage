<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<!-- Header !-->
	<head>
		<title>Ursinus CS 373: Theory of Computation, Fall 2025</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<!--[if lte IE 8]><script src="../../assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="../../assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="../../assets/css/ie8.css" /><![endif]-->
        <style>
        .image_off, #home:hover .image_on{
           display:none
        }
        .image_on, #home:hover .image_off{
           display:block
        }
        </style>
	</head>
	<body>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../../index.html" class="logo"><strong>Ursinus CS 373: Theory of Computation, Fall 2025</strong></a>
								</header>
<!-- End Header !-->

							<!-- Content -->
								<section>
									<header class="main">
                                        <h2>Week 4: Grep: Regular Expression Parsing And Evaluating</h2>
                                        <h3><a href = "http://www.ctralie.com">Chris Tralie</a>
									</header>

									<div id="page-content">

										<p>
											One of my <a href = "../../index.html#goals">learning goals</a> in this class is to <b>"use theory in non-obvious ways to create awesome practical solutions to problems."</b>  We saw the first real application of unit 1 to substring search on <a href = "../../Assignments/HW3_NFA/index.html#substring">problem 8 in HW3</a> with a simplified version of the Knuth-Morris Pratt (KMP) algorithm.  The non-obvious thing here (before taking TOC) was to use a DFA.  In fact, there are legends of some people being so confused about the source code of KMP when they had to maintain code containing it that they deleted it and replaced it with naive substring search (I'll find a citation for this story later).
										</p>

										<p>
											One even less obvious and even more powerful application is <b>regular expression search</b>; rather than searching for an exact string, we can search for a regular expression inside of text.  <i>This is the culmination of the first unit of the course.</i>
										</p>
										<p>
											In this writeup, we'll restrict ourselves to the slightly simpler case of seeing if the entirety of a particular string <b>s</b> is in the language generated by a regular expression <b>R</b>.  The non-obvious thing here is to convert the regular expression to an NFA, which can be efficiently evaluated, as <a href = "../Week4_NFACode/">we showed in code before</a>.  In fact, a more "naive" way of recursively exploring possible traversals of the regular expression without an NFA can lead to exponential time algorithms (see <a href = "https://swtch.com/~rsc/regexp/regexp1.html">this link</a> for a nice discussion about this which mirrors my writeup here).  On the other hand, NFA-based evaluation takes <b>O(len(s) len(R))</b> time in the worst case, and in practice, it's often closer to <b>O(len(s))</b>.  
										</p>

										<p>
											My goal in this document will be to explain a variant of the full pipeline for RegEx to NFA, as first outlined by Ken Thompson in his <a href = "https://www.oilshell.org/archive/Thompson-1968.pdf">seminal 1968 paper</a>.  We'll use python to be consistent with everything else we've done so far.  Before proceeding, you may want to review the <a href = "../Week4_NFACode/">notes on evaluating NFAs in python with and without &lambda;</a>, as I'll take that as a given, focusing mainly on the RegEx to NFA conversion in this document.
										</p>

										<p>
											In the discussion below, we have the following operators, with the following order of operations (where 3 is the highest precedence)
										</p>
										<ul>
											<li>
												<b>3</b> <code>*</code>: Star (repeat an arbitrary number of times, or no times)
											</li>
											<li>
												<b>2</b> <code>.</code>: Concatenation (the language on the left followed by the language on the right)
											</li>
											<li>
												<b>1</b> <code>|</code>: Union or "OR"; take the union of the two languages on either side
											</li>
										</ul>

										<hr>
										<h2><a name = "postfix">Step 1: Infix -> Postfix</a></h2>
										<p>
											Suppose we have the regular expression
										</p>
										<p>
											<code>((AB)*C)*B(C|(A*B))</code>
										</p>
										<p>											
											From an algorithm perspective, one challenge we immediately see is how to figure out what to look at first based on the parentheses and order of operations.  In fact, while this format of a regular expression, known as <b>infix notation</b>, is convenient for humans to read and group mentally, it's not as natural to computers.  Instead, we want to put the <b>operators</b> <code>*</code>, <code>|</code>, and <code>.</code> closer to the <b>operands</b> that they're applied to.  In the process, we'll also be able to eliminate parentheses completely.
										</p>

										<h4>Shorthand Expansion</h4>
										<p>
											Before we proceed, we'll take care of some shorthand with concatenation in the above expression.  We'll add a dot after every character not followed by any of <code>*|)</code>, as well as after every <code>*</code>.  Furthermore, we'll replace every single character <b>c</b> in the alphabet by <b>c_i</b>, where <b>i</b> is the order in which it occurs in the expression, just as we did in <a href = "../../Assignments/HW3_NFA/index.html#substring">problem 8 in HW3</a>.  If we do this on the above, we're left with the following: 
										</p>

										<p>
											<code>( ( A_0 . B_1 ) * . C_2 ) * . B_3 . ( C_4 | ( A_5 * . B_6 ) )</code>
										</p>

										<p>
											Now we're in a format that will be easier to describe systematically
										</p>

										<h4><a name = "infix2postfix">Algorithm 1: Infix To Postfix</a></h4>

										<p>
											Before we describe the algorithm to convert infix to postfix, let's look at what the postfix would be for the above
										</p>

										<p>
											<code>A_0 B_1 . * C_2 . * B_3 . C_4 A_5 * B_6 . | .</code>
										</p>

										<p>
											You'll notice that there are no more parentheses, and that the operators <code>.*|</code> are right next to the operands on which they are applied.
										</p>

										<p>
											To convert infix to postfix, we'll a stack to keep track of the operators.  The algorithm is simple enough to describe directly in python:
										</p>

										<script type="syntaxhighlighter" class="brush: python"><![CDATA[
											## Convert infix list to postfix list
											precedence = {"*":3, ".":2, "|":1} # Higher precedence means it should be done first
											postfix = []
											stack = []
											for x in infix: # Go through each infix character in order
												if x in precedence.keys():
													# If x is an operator
													while len(stack) > 0 and stack[-1] != "(" and precedence[x] <= precedence[stack[-1]]:
														# Pop off the stack while there would be a lower priority operation
														# under us, until we see a left parentheses, adding what we pop onto
														# the postfix expression as we go
														postfix.append(stack.pop())
													# When we're finished, we'll push this operator to the stack
													stack.append(x)
												elif x == "(":
													# If x is a left parentheses, simply push it onto the stack
													stack.append(x)
												elif x == ")":
													# If x is a right parentheses, pop everything off of the stack
													# until we see a matching right parentheses, adding what we 
													# pop onto the postfix expression as we go
													while len(stack) > 0 and stack[-1] != "(":
														postfix.append(stack.pop())
													stack.pop()
												else:
													# If x is an ordinary operand, put it directly into the postfix 
													# expression
													postfix.append(x)
											# Once we've run through the infix list, pop the rest of the operators from the stack and add to the postfix expression
											while len(stack) > 0:
												postfix.append(stack.pop())
										]]></script> 

										<p>
											Try it yourself on a piece of paper, and you'll see that we get the desired result on our example
										</p>

										<h2><a name = "nfa">Step 2: Postfix -> NFA with Evaluator Stack</a></h2>
										<p>
											Now that we have a good representation of our regular expression <b>R</b>, we can describe an algorithm to assemble an NFA out of it.  In the discussion that follows, we'll be working with <b>NFA fragments</b>, which are smaller machines that we will incrementally splice into each other to make the entire automaton that recognizes the language generated by <b>R</b>.  We'll assume that every NFA fragment has the following form:
										</p>

										<img src = "NFAFragment.svg" width="50%">

										<p>
											That is, every NFA fragment has exactly one arrow going into it at a state called <code>in</code>, with an unspecified character transitioning into it, as well as exactly one arrow going out of it which transitions on the arrow with character <b>c</b>.
										</p>

										<h3><a name = "splicealg">Algorithm 2: Postfix RegEx To NFA</a></h3>
										<p>
											The algorithm to splice together NFA fragments incrementally uses a stack.  The overall pseudocode is as follows:
										</p>

										<script type="syntaxhighlighter" class="brush: python"><![CDATA[
											def make_nfa(R_postfix):
												stack = [] # Stack for NFA fragments.  Consists of tuples of (in, out, c)

												for c in R_postfix: # Assuming the convention c_i for each operand
													if c is *
														(in1, out1, c1) = stack.pop()
														# Create meta * machine around (in1, out1, c1)
														# and push it onto the stack
													elif c is . or |:
														(in2, out2, c2) = stack.pop()
														(in1, out1, c1) = stack.pop()
														# Create a meta machine around (in1, out1, c1)
														# and (in2, out2, c2) and push it onto the stack
													else:
														# Ordinary operand c_i, add directly to the stack
														# as a primitive fragment transitioning on 
														# character c[0]
														stack.push((c, c, c[0]))
												
												# Take out the last element in the stack, and add 
												# a lambda arrow from state "Start" to in and an arrow 
												# from out to state "Finish" to complete the machine
												

										]]></script> 

										<p>
											Now let's describe the assembly process to create the meta machines for <code>*</code>, <code>.</code>, and <code>|</code>
										</p>

										<h3><a name = "starmeta">Star <code>*</code> Meta Machine</a></h3>

										<p>
											The image below shows the meta machine that we create to put a <code>*</code> around an NFA fragment <code>(in, out, c)</code>:
										</p>

										<img src = "StarMeta.svg" width="80%">

										<p>
											The result is a new NFA fragment <code>(in_*start, out_*end, &lambda;)</code> in place of the original NFA fragment.  To get here, we create two new states <code>in_*start</code> and <code>out_*end</code>, as well as 4 arrows (highlighted in red):
											<ul>
												<li>
													A &lambda; arrow to go <b>into</b> and run the NFA fragment we're wrapping around
												</li>
												<li>
													A &lambda; arrow to <b>skip</b> the NFA fragment entirely, since we can take the empty string &lambda; with the <code>*</code> 
												</li>
												<li>
													A &lambda; arrow to <b>repeat</b> the NFA fragment we're wrapping around, since we can loop through it an arbitrary number of times with the <code>*</code>
												</li>
												<li>
													An arrow to leave this entire block through the NFA fragment's end character <b>c</b>
												</li>
											</ul>
										</p>

										<h3><a name = "concatmeta">Concatenation <code>.</code> Meta Machine</a></h3>

										<p>
											The image below shows how to create the meta fragment performing a concatenation of two NFA fragments <code>(in1, out1, c1)</code> and <code>(in2, out2, c2)</code> 
										</p>

										<img src = "ConcatMeta.svg" width="80%">

										<p>
											The result is a new NFA fragment <code>(in1, out2, c2)</code> in the place of the original two fragments.  To get here, we add a single arrow from <code>out1</code> to <code>in2</code> along the character <b>c1</b> to glue the two fragments together.  We don't actually need to create any new states
										</p>

										<h3><a name = "unionmeta">Union <code>|</code> Meta Machine</a></h3>

										<p>
											The image below shows how to create the meta fragment performing a union of two NFA fragments <code>(in1, out1, c1)</code> and <code>(in2, out2, c2)</code> 
										</p>

										<img src = "UnionMeta.svg" width="80%">

										<p>
											The result is a new NFA fragment <code>(in1_|start, out2_|end, &lambda;)</code> in the place of the original two fragments, which branches out nondeterministically out into one of the original NFA fragments and forces the automaton to execute at least one of them to pass onto the next phase.  To accomplish this, we add the two new states <code>in1_|start</code> and <code>out2_|end</code>, as well as the following four arrows (highlighted in red):  
										</p>
										<ul>
											<li>
												A &lambda; arrow from <code>in1_|start</code> to <code>in1</code> to <b>run the first NFA fragment as a possibility</b>
											</li>
											<li>
												A &lambda; arrow from <code>in1_|start</code> to <code>in2</code> to <b>run the second NFA fragment as a possibility</b>
											</li>
											<li>
												An arrow from <code>out1</code> to <code>out2_|end</code> along the character <code>c1</code> to <b>finish the first machine and continue</b>
											</li>
											<li>
												An arrow from <code>out2</code> to <code>out2_|end</code> along the character <code>c2</code> to <b>finish the second machine and continue</b>
											</li>
										</ul>

										<HR>
										<h2><a name = "workedexample">Worked Example</a></h2>
										<p>
											It's worth now doing a full example of <a href = "#splicealg">algorithm 2</a> on a postfix regular expression.  We'll start with the example 
										</p>

										<p>
											<code>((AB)*C)*B(C|(A*B))</code>
										</p>

										<p>
											which, in postfix, is 
										</p>

										<p>
											<code>A_0 B_1 . * C_2 . * B_3 . C_4 A_5 * B_6 . | .</code>
										</p>

										<p>
											First, we see <code>A_0</code> and <code>B_1</code>, which are ordinary operands.  We push primitive NFA fragments for each onto the stack in that order:
										</p>

										<p>
											<code><b>A_0 B_1</b> . * C_2 . * B_3 . C_4 A_5 * B_6 . | .</code>
										</p>

										<img src = "Example2/1.svg" width="20%">

										<p>
											Next, we see a concatenation character <b>.</b>
										</p>

										<p>
											<code>A_0 B_1 <b>.</b> * C_2 . * B_3 . C_4 A_5 * B_6 . | .</code>
										</p>

										<p>
											We'll pop off the top two elements and create a meta machine according to the <a href = "#concatmeta">concatenation meta machine recipe</a>, pushing the resulting meta fragment back onto the stack:
										</p>

										<img src = "Example2/2.svg" width="30%">

										<p>
											Next, we see a <b>*</b>
										</p>
										<p>
											<code>A_0 B_1 . <b>*</b> C_2 . * B_3 . C_4 A_5 * B_6 . | .</code>
										</p>
										<p>
											We'll pop off the top element of the stack and wrap it into the <a href = "#starmeta">star meta machine</a>, pushing the resulting fragment back onto the stack:
										</p>

										<img src = "Example2/3.svg" width="60%">

										<p>
											Next, we see an ordinary operand <code>C_2</code>
										</p>
										<p>
											<code>A_0 B_1 . * <b>C_2</b> . * B_3 . C_4 A_5 * B_6 . | .</code>
										</p>
										<p>
											
											so we simply push its primitive NFA fragment onto the stack:
										</p>

										<img src = "Example2/4.svg" width="60%">

										<p>
											Next, we see a concatenation operator <code>.</code>
										</p>
										<p>
											<code>A_0 B_1 . * C_2 <b>.</b> * B_3 . C_4 A_5 * B_6 . | .</code>
										</p>

										<p>
											So we pop off the top two elements and connect them together, pushing the result back on top of the stack:
										</p>

										<img src = "Example2/5.svg" width="64%">

										<p>
											Next, we see a <code>*</code> operator
										</p>
										<p>
											<code>A_0 B_1 . * C_2 . <b>*</b> B_3 . C_4 A_5 * B_6 . | .</code>
										</p>

										<p>
											We'll pop off the top element of the stack and wrap it into the <a href = "#starmeta">star meta machine</a>, pushing the resulting fragment back onto the stack:
										</p>

										<img src = "Example2/6.svg" width="90%">

										<p>
											Next, we see an ordinary operand <code>B_3</code> 
										</p>
										<p>
											<code>A_0 B_1 . * C_2 . * <b>B_3</b> . C_4 A_5 * B_6 . | .</code>
										</p>
										<p>
											so we push a corresponding primitive NFA fragment onto the stack
										</p>

										<img src = "Example2/7.svg" width="90%">

										<p>
											Next, we see a concatenation operator <code>.</code>
										</p>
										
										<p>
											So we pop off the top two elements and glue them together, pushing the result onto the stack
										</p>

										<img src = "Example2/8.svg" width="90%">
											
										<p>
											Next, we see two primitive operands <code>C_4</code> and <code>A_5</code>
										</p>
										
										<p>
											<code>A_0 B_1 . * C_2 . * B_3 . <b>C_4 A_5</b> * B_6 . | .</code>
										</p>

										<p>
											and we push their corresponding primitive NFA fragments onto the stack in that order
										</p>

										<img src = "Example2/9.svg" width="90%">

										<p>
											Next, we see a <code>*</code> operator
										</p>
										<p>
											<code>A_0 B_1 . * C_2 . * B_3 . C_4 A_5 <b>*</b> B_6 . | .</code>
										</p>

										<p>
											We'll pop off the top element of the stack and wrap it into the <a href = "#starmeta">star meta machine</a>, pushing the resulting fragment back onto the stack:
										</p>

										<img src = "Example2/10.svg" width="90%">

										<p>
											Next, we see an ordinary operand <code>B_6</code> 
										</p>
										<p>
											<code>A_0 B_1 . * C_2 . * B_3 . C_4 A_5 * <b>B_6</b> . | .</code>
										</p>
										<p>
											and we push the corresponding primitive NFA fragment onto the stack
										</p>

										<img src = "Example2/11.svg" width="90%">

										<p>
											Next, we see a concatenation character <b>.</b>
										</p>

										<p>
											<code>A_0 B_1 . * C_2 . * B_3 . C_4 A_5 * B_6 <b>.</b> | .</code>
										</p>

										<p>
											We'll pop off the top two elements and create a meta machine according to the <a href = "#concatmeta">concatenation meta machine recipe</a>, pushing the resulting meta fragment back onto the stack:
										</p>

										<img src = "Example2/12.svg" width="90%">

										<p>
											Next, we see a union character <b>|</b>
										</p>

										<p>
											<code>A_0 B_1 . * C_2 . * B_3 . C_4 A_5 * B_6 . <b>|</b> .</code>
										</p>

										<p>
											We'll pop off the top two elements and create a meta machine according to the <a href = "#unionmeta">union meta machine recipe</a>, pushing the resulting meta fragment back onto the stack:
										</p>

										<img src = "Example2/13.svg" width="90%">

										<p>
											Finally, we see a concatenation character <b>.</b>
										</p>

										<p>
											<code>A_0 B_1 . * C_2 . * B_3 . C_4 A_5 * B_6 . | <b>.</b></code>
										</p>

										<p>
											We'll pop off the top two elements and create a meta machine according to the <a href = "#concatmeta">concatenation meta machine recipe</a>, pushing the resulting meta fragment back onto the stack:
										</p>

										<img src = "Example2/14.svg" width="90%">

										<p>
											The last step is to create a start state <code>Start</code> where we start and an end state <code>Finish</code> where we accept.  We pop off the only element that's left on the stack, we feed <code>Start</code> into the beginning of that element with a &lambda; arrow, and then we feed the end of that machine into <code>Finish</code> with the character coming out of it:
										</p>

										<p>
											<img src = "Example2/15.svg" width="95%">
										</p>

										<p>
											This is the final result for the regular expression <code>((AB)*C)*B(C|(A*B))</code>!
										</p>

                                    
                                </div>
						</div>
					</div>

					<!--LaTeX in Javascript!-->
					<script src="../../../../jsMath/easy/load.js"></script>
					<!--Syntax highlighting in Javascript!-->
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shCore.js"></script>
					<script type="text/javascript" src="../../../syntaxhighlighter/scripts/shBrushJScript.js"></script>
                    <script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushCpp.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushXml.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushMatlabSimple.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushPython.js"></script>
					<link type="text/css" rel="stylesheet" href="../../../../syntaxhighlighter/styles/shCoreDefault.css"/>
					<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">
							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<h2>Menu</h2>
									</header>
									<ul>
                                        <li>
											<span class="opener">General</span>
											<ul>
												<li><a href = "../../index.html#overview">Overview</a></li>
												<li><a href = "../../index.html#logistics">Technology Logistics</a></li>
												<li><a href = "../../index.html#readings">Readings</a></li>
												<li><a href = "../../index.html#deliverables">Deliverables</a></li>
												<li><a href = "../../index.html#schedule">Schedule</a></li>
												<li><a href = "../../index.html#grading">Grading</a></li>
												<li><a href = "../../index.html#environment">Classroom Environment</a></li>
												<li><a href = "../../index.html#collaboration">Collaboration Policy</a></li>
												<li><a href = "../../index.html#other">Other Resources / Policies</a></li>
											</ul> 
										</li>
										<li><a href = "../../Software/index.html">Software</a></li>
										<li><a href = "../../index.html#schedule">Schedule</a></li>
										<li><a href = "../../FinalProject/index.html">Final Project</a></li>
                                        <li>
											<span class="opener">Assignments</span>
											<ul>
												<li>
													<a href = "../../Assignments/HW1_Discrete/index.html">HW1: Discrete Math Practice</a>
												</li>
												<li>
													<a href = "../../Assignments/HW2_DFA/index.html">HW2: DFAs</a>
												</li>
												<li>
													<a href = "../../Assignments/HW3_NFA/index.html">HW3: DFAs And NFAs</a>
												</li>
												<li>
													<a href = "../../Assignments/HW4_Regexp/index.html">HW4: Regular Expressions And Nonregular Languages</a>
												</li>
												<li>
													<a href = "../../Assignments/HW5_CFGs/index.html">HW5: Context Free Grammars And Pushdown Automata</a>
												</li>
												<li>
													<a href = "../../Assignments/HW6_Turing/index.html">HW6: Turing Machines</a>
												</li>
												<li>
													<a href = "../../Assignments/HW7_Turing2/index.html">HW7: Turing Machines, Turing Enumerators, And Decidability</a>
												</li>
												<li>
													<a href = "../../Assignments/HW8_Decidability/index.html">HW8: Decidability</a>
												</li>
												<li>
													<a href = "../../Assignments/HW9_Computability/index.html">HW9: Computability</a>
												</li>
											</ul>
										</li>
                                        <li>
											<span class="opener">Class Exercises</span>
											<ul>
												<li><a href = "../../ClassExercises/Week1_Unplugged">Week 1: Acting Out DFAs</a></li>
												<li><a href = "../../ClassExercises/Week1_Discrete">Week 1: Discrete Math Review</a></li>
												<li><a href = "../../ClassExercises/Week1_FridayDFABinary">Week 1: Binary And JFLAP</a>
													<ul>
														<li><a href = "../../ClassExercises/Week1_FridayDFABinary/index.html#binary">Binary Drills</a></li>
														<li><a href = "../../ClassExercises/Week1_FridayDFABinary/index.html#jflap">JFLAP Exercises</a></li>
													</ul>
												</li>
												<li><a href = "../../ClassExercises/Week2_Formal">Week 2: Formal Description of DFAs, Divisibility</a>
													<ul>
														<li>
															<a href = "../../ClassExercises/Week2_Formal/index.html#formalcode">Formal Regular Languages: Code</a>
														</li>
													</ul>
												</li>
												<li><a href = "../../ClassExercises/Week2_Union">Week 2: Union of Regular Languages</a></li>
												<li><a href = "../../ClassExercises/Week3_NFAs">Week 3: Nondeterministic Finite Automata (NFAs), Reversing Regular Languages</a></li>
												<li><a href = "../../ClassExercises/Week3_NFAToDFA">Week 3: NFAs Recognize Regular Languages (i.e. NFAs To DFAS)</a></li>
												<li><a href = "../../ClassExercises/Week4_NFACode">Week 4: Efficiently Evaluating NFAs in Python with and without Lambda</a></li>
												<li><a href = "../../ClassExercises/Week4_DFAToRegexp">Week 4: Converting Regular Expressions To DFAs And Back</a></li>
												<li><a href = "../../ClassExercises/Week4_Grep">Week 4: Grep: Regular Expression Parsing And Evaluating</a></li>
												<li><a href = "../../ClassExercises/Week5_PumpingLemma">Week 5: The Pumping Lemma</a></li>
												<li><a href = "../../ClassExercises/Week7_Turing">Week 7/8: Turing Machine Examples</a></li>
												<li><a href = "../../ClassExercises/Week8_MultitapeTuring">Week 8: Multitape Turing Machine Examples</a></li>
												<li><a href = "../../ClassExercises/Week10_Decidability">Week 10: Decidability</a></li>
												<li><a href = "../../ClassExercises/Week11_Infinities">Week 11: Countable And Uncountable Infinities</a></li>
												<li><a href = "../../ClassExercises/Week12_Undecidability">Week 12: Undecidability</a></li>
												<li><a href = "../../ClassExercises/Week13_Modules/video1.html">Week 13: The Class P</a></li>
												<li><a href = "../../ClassExercises/Week13_Modules/video2.html">Week 13: The Class NP</a></li>
												<li><a href = "../../ClassExercises/Week14_CookLevin">Week 14: Cook Levin Theorem And SAT Solving</a></li>
											</ul>
										</li>
									</ul>
								</nav>


							<!-- Footer -->
								<footer id="footer">
									<p class="copyright">&copy; <a href = "http://www.ctralie.com">Christopher J. Tralie</a>. All rights reserved.  Contact chris.tralie@gmail.com. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
								</footer>

						</div>
					</div>

			</div>
			
            <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- End Sidebar !-->

<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/skel.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="../../assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="../../assets/js/main.js"></script>
<!-- End Scripts -->
