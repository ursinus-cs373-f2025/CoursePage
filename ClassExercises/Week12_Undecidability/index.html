<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<!-- Header !-->
	<head>
		<title>Ursinus CS 373: Theory of Computation, Fall 2025</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<!--[if lte IE 8]><script src="../../assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="../../assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="../../assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="../../assets/css/ie8.css" /><![endif]-->
        <style>
        .image_off, #home:hover .image_on{
           display:none
        }
        .image_on, #home:hover .image_off{
           display:block
        }
        </style>
	</head>
	<body>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header">
									<a href="../../index.html" class="logo"><strong>Ursinus CS 373: Theory of Computation, Fall 2025</strong></a>
								</header>
<!-- End Header !-->

							<!-- Content -->
								<section>
									<header class="main">
                                        <h2>Week 12: Undecidability</h2>
                                        <h3><a href = "http://www.ctralie.com">Chris Tralie</a>
									</header>

									<div id="page-content">
										<p>
											It's now time to consider some languages that are not decidable.  If a language <b>L</b> is not decidable, it means that while it may be possible to design a Turing machine to recognize <b>L</b>, we can't hope to avoid an infinite loop on all strings not in the language.
										</p>

										<p>
											We'll start with a very specific example of an undecidable language known as <b>A<SUB>TM</SUB></b>, which we will use as the canonical undecidable language when proving that other languages are undecidable.  It will be one very short step after this to prove that the ever famous <b>Halting problem</b> is undecidable, but that is <b>just the tip of the iceberg of interesting problems we can't hope to solve in general</b>, as we will see ðŸ˜¿ðŸ˜¿ðŸ˜¿.
										</p>

										<HR>
										<h2><a name = "atm">A<SUB>TM</SUB> Is Undecidable</a></h2>

										<p>
											We define a language called <b>A<SUB>TM</SUB></b> which is the Turing machine version of <a href = "../Week10_Decidability/index.html#adfa">A<SUB>DFA</SUB></a> and <a href = "../Week10_Decidability/index.html#acfg">A<SUB>CFG</SUB></a>
										</p>

										<h4>
											A<SUB>TM</SUB> = {&lt;M,w&gt; | M is a Turing machine and M accepts the string w}
										</h4>

										<p>
											<b>Claim: </b>Unlike <b>A<SUB>DFA</SUB></b> and <b>A<SUB>CFG</SUB></b>, however, <b>A<SUB>TM</SUB></b> is <b>not</b> decidable.  
										</p>

										<p>
											<b>Proof: </b> Intuitively, there's something about the fact that Turing machines can throw infinite loops that prevent us from being able to rule out a particular string from just taking a long time to accept/reject or from actually infinitely looping.  But we need a more rigorous argument for this.
										</p>
										<p>
											<a name = "atmdecidable">Suppose by contradiction that <b>A<SUB>TM</SUB></b> is actually decidable</a>, and let a decider for it be a machine called <b>A</b>.  Then we can use <b>A</b> as a subroutine to build another decidable universal Turing machine which I'll call <b>weird</b> (following <a href = "https://www.youtube.com/watch?v=r__GZ7ubU0M">Thorsten Altenkirch's convention</a>).  Below is a high level description of this machine, which feeds a <a href = "../Week10_Decidability/index.html#encodings">string encoding</a> of <b>M</b> to itself:
										</p>

										<script type="syntaxhighlighter" class="brush: python"><![CDATA[
											def weird(M):
												"""
												We run ATM's decider A to say if M accepts the string 
												representation of itself, and we do the opposite
												"""
												if A(<M, <M>>) Accepts: 
													weird Rejects
												else:
													weird Accepts
										</script> 

										<p>
											In other words, <b>weird</b> does the opposite of <b>A</b> on the string encoding of a machine and itself.  Since <b>A</b> is assumed to be a decidable Turing machine, so is <b>weird</b>.  But here's a <b>diagonalization argument</b> can run us into trouble.  Since the <a href = "../Week11_Infinities/index.html#turingcountable">set of all Turing machines is countable</a>, we can arrange all possible Turing machines along the rows of a table in some order (such as the lexographic order of their string encoding).  We'll then order their string encodings in the same order across the columns.  In the entries of the table, let's record <b>Accept</b> or <b>Reject</b> to indicate whether the machine on the row accepts or rejects the string encoding of the machine on the column.  Since we've assumed that <b>A<SUB>TM</SUB></b> is decidable, then these are the only two possibilities for its decider <b>A</b>.  For instance, here's that table on six arbitrary Turing machines <b>M<SUB>1</SUB> ... M<SUB>6</SUB></b>
										</p>

										<table style="width:600px;">
											<tr><td></td>
												<td><h4>&lt;M<SUB>1</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>2</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>3</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>4</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>5</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>6</SUB>&gt;</h4></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M1</h4></td>
												<td><h3><span style="color: red;">Accept</span></h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M2</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Accept</span></h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M3</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Accept</span></h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Reject</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M4</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Reject</span></h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Reject</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M5</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Reject</span></h3></td>
												<td><h3>Accept</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M6</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Accept</span></h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td>
											</tr>
										</table>

										<p>
											<i>But we just argued a moment ago that <b>weird</b> is a valid Turing machine</i>, so we should be able to have a row and column for <b>weird</b> and its string encoding <b>&lt;weird&gt;</b>, respectively, in our table.  Since <b>weird</b> does the reverse behavior of <b>A</b> on a machine and its string encoding, the value of <b>weird</b>'s row at the <b>i<SUP>th</SUP></b> column should be the opposite of the <b>i<SUP>th</SUP></b> diagonal entry of the table.  Let's try to do this:
										</p>

										<table style="width:600px;">
											<tr><td></td>
												<td><h4>&lt;M<SUB>1</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>2</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>3</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>4</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>5</SUB>&gt;</h4></td>
												<td><h4>&lt;M<SUB>6</SUB>&gt;</h4></td>
												<td>...</td>
												<td>
													<h4>&lt;weird&gt;</h4>
												</td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M1</h4></td>
												<td><h3><span style="color: red;">Accept</span></h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td>...</td>
												<td><h3>Reject</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M2</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Accept</span></h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td>...</td>
												<td><h3>Reject</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M3</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Accept</span></h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Reject</h3></td>
												<td>...</td>
												<td><h3>Reject</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M4</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Reject</span></h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Reject</h3></td>
												<td>...</td>
												<td><h3>Accept</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M5</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Reject</span></h3></td>
												<td><h3>Accept</h3></td>
												<td>...</td>
												<td><h3>Reject</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td><h4>M6</h4></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Reject</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3>Accept</h3></td>
												<td><h3><span style="color: red;">Accept</span></h3></td>
												<td>...</td>
												<td><h3>Accept</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td>
											</tr>
											<tr>
												<td><h4>weird</h4></td>
												<td><h3><span style="color: #31caca;">Reject</span></h3></td>
												<td><h3><span style="color: #31caca;">Reject</span></h3></td>
												<td><h3><span style="color: #31caca;">Reject</span></h3></td>
												<td><h3><span style="color: #31caca;">Accept</span></h3></td>
												<td><h3><span style="color: #31caca;">Accept</span></h3></td>
												<td><h3><span style="color: #31caca;">Reject</span></h3></td>
												<td>...</td>
												<td><h3>ðŸ™€ðŸ™€???ðŸ™€ðŸ™€</h3></td>
												<td>...</td>
											</tr>
											<tr>
												<td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td>
											</tr>
										</table>

										<p>
											We start off just fine by having <b>weird</b> do the opposite on other machines.  However, when we get to <b>weird</b> itself, we reach a contradiction, because we define its accept/reject status to be the opposite of what it is.  But it's impossible to choose either accept or reject to be the opposite of itself.  So we've arrived at a contradiction.  The only falsifiable assumption we made this whole time is that <a href = "#atmdecidable">A<SUB>TM</SUB> is decidable</a>.  Therefore, A<SUB>TM</SUB> must not be decidable!
										</p>

										<h3><a name = "diagonalizationdisclaimer">Diagonalization Disclaimer!!</a></h3>
										<p>
											Most math students would be used to using a diagonalization argument to prove that certain sets are <a href = "../Week11_Infinities/index.html#uncountable">uncountably infinite</a>.  But that's not what we're showing with <b>A<SUB>TM</SUB></b>!  Actually, as we discussed, the set of all strings in an alphabet is <a href = "../Week11_Infinities/index.html#alphabet">countably infinite</a>, and every language is a subset of these strings, so every language must be countable, whether it's decidable or not.  So even though <b>A<SUB>TM</SUB></b> is undecidable, it is still countably infinite!  <b>So don't make the mistake of assuming that undecidable languages are uncountable!</b>
										</p>
										<p>
											At the root of the confusion is <b>exactly what we're assuming by contradiction before we apply the diagonal argument</b>.  When we prove that a set is uncountable, we assume by contradiction that it is countable, and then we find an inconsistency with the diagonal argument.  By contrast, when we show that <b>A<SUB>TM</SUB></b> is undecidable, we are not assuming countability of the set of languages by contradiction, because <a href = "../Week11_Infinities/index.html#turingcountable">that is already true</a>!  Instead, we're assuming by contradiction the <b>existence of an oracle</b>.  So in this case, we use the contradiction with a diagonal argument to disprove the existence of an oracle.
										</p>

										<HR>
											<h2><a name = "halttm">Halt<SUB>TM</SUB> Is Undecidable</a></h2>

											<iframe width="560" height="315" src="https://www.youtube.com/embed/85FW5SvmNSs?si=HSCBF8aULO7MER11" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

											<p>
												We can now talk about the problem that everyone mentions as the canonical undecidable problem: the halting problem:
											</p>

											<h4>
												Halt<SUB>TM</SUB> = {&lt;M,w&gt; | M is a Turing machine and M halts (either accepts or rejects, but does not loop) on the string w}
											</h4>

											<p>
												Personally, I think <b>A<SUB>TM</SUB></b> is easier to use as the canonical undecidable problem, but it doesn't matter, because it's relatively straightforward to reduce <b>A<SUB>TM</SUB></b> to the halting problem.  We will use the following theorem to our advantage
											</p>

											<div style="background-color: blanchedalmond; padding:10px;">
												<a name = "reduction"><h4>Reduction Strategy for Proving Undecidability</h4></a>

												<p>
													If a problem <b>A</b> is undecidable, then we assume by contradiction that <b>B</b> is decidable and use a decider machine for problem <b>B</b> as a subroutine to solve problem <b>A</b>.  If we ensure that everything other than <b>B</b>'s decider takes decidable steps, then we reach the conclusion that <b>A</b> is decidable.  But this is a contradiction, so our assumption that <b>B</b> was decidable must be false, proving that <b>B</b> is undecidable.
												</p>

											</div>
											<p></p>
											<p>
												Let's use this strategy to prove that <b>Halt<SUB>TM</SUB></b> is undecidable.  We'll use <b>A<SUB>TM</SUB></b> as problem <b>A</b> and <b>Halt<SUB>TM</SUB></b> as problem <b>B</b>.  If we assume by contradiction that <b>Halt<SUB>TM</SUB></b> is decidable, then there must exist a decider machine <b>H</b> for this problem.  We can use <b>H</b> to define the following machine to decide <b>A<SUB>TM</SUB></b>
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def ATM(<M, w>):
													if H(<M, w>) Accepts:
														# Our presumed decidable halting machine tells indicates that M halts on w
														# Therefore, it is safe to run it to see if it accepts/Rejects
														Run M on w
														if M Accepts w:
															Accept
														else:
															Reject
													else:
														# If HaltTM rejects, this means M goes into an infinite
														# loop on w.  Therefore, M does not accept w
														Reject 
											</script> 

											<p>
												This is, of course, a contradiction, since we know that <b>A<SUB>TM</SUB></b> is undecidable.  Therefore, our assumption that <b>Halt<SUB>TM</SUB></b> is decidable is false, so <b>Halt<SUB>TM</SUB></b> must be undecidable.
											</p>

										<HR>
											<h2><a name = "etm">E<SUB>TM</SUB> Is Undecidable</a></h2>

											<p>
												A lot of times the halting problem is stated as the be all end all of undecidability.  But there are (sadly) so many other useful problems that we cannot hope to solve in general.  Let's now consider one called <b>E<SUB>TM</SUB></b>, which is the Turing machine equivalent of <a href = "../Week10_Decidability/index.html#edfa">E<SUB>DFA</SUB></a> and <a href = "../Week10_Decidability/index.html#ecfg">E<SUB>CFG</SUB></a>
											</p>

											<h4>
												E<SUB>TM</SUB> = {&lt;M&gt; | M is a Turing machine that does not accept anything}
											</h4>

											<p>
												<b>Claim: </b> E<SUB>TM</SUB> is undecidable
											</p>

											<p>
												<b>Proof: </b> We'll follow the same strategy by assuming by contradiction that <b>E<SUB>TM</SUB></b> is decidable.  Let's say we have a decider machine <b>E</b> for this language, which we'll use to create a machine to decide <b>A<SUB>TM</SUB></b>.  To do this, let's define a third machine that will help us:
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def EmptyIndicator_M_w(s):
													if M Accepts w:
														if s == "CS 373 Rocks": # This could be any string
															Accept
														else:
															Reject
													else:
														Reject
											</script> 

											<p>
												This is kind of a weird trick, but we've defined a machine <b>EmptyIndicator_M_w</b> whose definition depends on a machine <b>M</b> and a string <b>w</b>, so the machine will actually change for a different <b>M</b> and <b>w</b>.  But when we fix <b>M</b> and <b>w</b>, we see that the language <b>L(EmptyIndicator_M_w)</b> is empty if <b>M</b> does not accept <b>w</b>, or it consists of a single string <b>"CS 373 Rocks"</b> if <b>M</b> does accept <b>w</b>.  Therefore, we can create a decider for <b>A<SUB>TM</SUB></b> by using <b>E<SUB>TM</SUB></b>'s decider <b>E</b>
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def ATM(<M, w>):
													if E(<EmptyIndicator_M_w>) Accepts:
														# The language accepted by the machine is only empty
														# if M rejects w
														Reject 
													else:
														Accept
											</script> 

											<p>
												Since we know that <b>A<SUB>TM</SUB></b> is undecidable, we've reached a contradiction, and <b>E<SUB>TM</SUB></b> must not be decidable.
											</p>

											<p>
												The thing that's weird about this proof is that the machine <b>EmptyIndicator_M_w</b> does not have to be a decider for us to decide whether it's empty by our assumption; we assumed that <b>E<SUB>TM</SUB></b> can decide whether <i>any</i> machine is empty.  And this was enough for us to complete the proof by contradiction.
											</p>

										<HR>
											<h2><a name = "regtm">Reg<SUB>TM</SUB> Is Undecidable</a></h2>

										<p>
											There's another fact we might love to know about a Turing machine we have (or about a computer program that we have, as per the Church-Turing Thesis): did we go way overkill but it can actually just be implemented as a DFA?  This machine could have solved <a href = "../../Assignments/HW6_Turing/index.html#problem5">problem 5 on homework 6</a> with the "broken Turing machines," for example.  For a more specific example, let's consider the following Turing machine:
										</p>

										<img src = "RegTM_TM.png">
										
										<p>
											This Turing machine decides the language of binary strings with at least one 0.  But this can be implemented more simply by just using a DFA
										</p>

										<img src = "RegTM_DFA.png">

										<p>
											Let's now state the language in question more formally
										</p>

										<h4>
											Reg<SUB>TM</SUB> = {&lt;M&gt; | M is a Turing machine and the language L(M) generated by M can be recognized by a DFA}
										</h4>

										<p>
											<b>Claim: </b> <b>Reg<SUB>TM</SUB></b> is undecidable
										</p>

										<p>
											<b>Proof: </b> As per procedure, we'll assume by contradiction that <b>Reg<SUB>TM</SUB></b> is decidable and use it to create a decider for <b>A<SUB>TM</SUB></b>.  Let's assume a decider for <b>Reg<SUB>TM</SUB></b> is called <b>R</b>.  We'll use a similar trick to the one we used for <b>E<SUB>TM</SUB></b> and design an auxiliary machine that we'll eventually feed to <b>Reg<SUB>TM</SUB></b>
										</p>

										<script type="syntaxhighlighter" class="brush: python"><![CDATA[
											def RegIndicator_M_w(s):
												if M Accepts w:
													if s is in 0*1*: # This could be any regular expression
														Accept
													else:
														Reject
												else:
													if s is in {0^n1^n, n >= 0}: # This could be any nonregular language
														Accept
													else:
														Reject
										</script> 

										<p>
											When we fix <b>M</b> and <b>w</b>, we see that the language <b>L(RegIndicator_M_w)</b> happens to be regular if <b>M</b> accepts <b>w</b>, or it happens to be nonregular if <b>M</b> does not accept <b>w</b>.  Therefore, we can create a decider for <b>A<SUB>TM</SUB></b> by using <b>Reg<SUB>TM</SUB></b>'s decider <b>R</b> on <b>RegIndicator_M_w</b>
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def ATM(<M, w>):
													if R(<RegIndicator_M_w>) Accepts:
														# The language accepted by the machine is only
														# regular if M accepts w
														Accept
													else:
														Reject
											</script> 
										</p>
										<p>
											We know <b>A<SUB>TM</SUB></b> is undecidable, so we've reached a contradiction, and <b>Reg<SUB>TM</SUB></b> must be undecidable as well.
										</p>

										
										<HR>
											<h2><a name = "TwoWritetm">TwoWrite<SUB>TM</SUB> Is Undecidable</a></h2>

											<p>
												Let's consider one more language for good measure.  Suppose we have a 2-tape turing machine.  Then we claim the language 
											</p>

											<h4>
												TwoWrite<SUB>TM</SUB> = {&lt;M,w&gt; | M is a 2-tape Turing machine that writes a non-blank symbol to its second tape while processing w}
											</h4>

											<p>
												is undecidable
											</p>

											<p>
												<b>Proof: </b> We can create a fairly straightforward decider for <b>A<SUB>TM</SUB></b> if we assume by contradiction that <b>TwoWrite<SUB>TM</SUB></b> is decidable.  Let's create an auxiliary "wrapper machine" <b>TwoWrite_Accept_M</b> for any single tape turing machine <b>M</b>.  This machine runs <b>M</b> on an input as normal, and if <b>M</b> accepts <b>w</b>, then it writes a single <b>1</b> on the second tape.  Hence, this machine writes a non-blank symbol on the second tape if and only if <b>M</b> accepts <b>w</b>.  Written out in pseudocode, we have:
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def TwoWrite_Accept_M(w):
													Run M on w using the first tape 
													if M accepts w:
														Write a 1 to the second tape
											</script>

											<p>
												Used to decide <b>A<SUB>TM</SUB></b>, we then have
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def ATM(<M, w>):
													if TwoWriteTM(<TwoWrite_Accept_M>) Accepts:
														Accept
													else:
														Reject
											</script>

											<p>
												Hence, <b>TwoWrite<SUB>TM</SUB></b> cannot be decidable.
											</p>
										

										<HR>
											<h2><a name = "rice">Rice's Theorem</a></h2>
											<iframe width="560" height="315" src="https://www.youtube.com/embed/43GAeHyXCmo?si=S-vwBbKa0YNznVaN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

											<p>
												It may seem like we keep doing a similar thing for all of these problems, and we'd be able to save ourselves some work if we came up with a more general theorem for a class of undecidable languages that all have certain things in common.  Here, we'll explore one such theorem known as <b>Rice's Theorem</b>.
											</p>

											<div style="background-color: blanchedalmond; padding:10px;">
												<h4>Rice's Theorem</h4>

												<p>
													Let <b>P</b> be a language of Turing machine string encodings satisfying some property that meets two conditions
												</p>
												<ol>
													<li>
														<p>
															This property is <b>nontrivial</b>; there is at least one Turing machine that satisfies this property, but not all Turing machines satisfy this property.
														</p>
													</li>
													<li>
														<p>
															This property applies to the <b>language</b> associated to Turing machines, not to specific implementation details of Turing machines; that is, if the language <b>L(M<SUB>1</SUB>)</b> associated to machine <b>M<SUB>1</SUB></b> fulfills this property (and hence <b>&lt;M<SUB>1</SUB>&gt; &isin; P</b>), then <b>M<SUB>2</SUB></b> satisfies this property (<b>&lt;M<SUB>2</SUB>&gt; &isin; P</b>) if and only if <b>L(M<SUB>1</SUB>) = L(M<SUB>2</SUB>)</b>.
														</p>
													</li>
												</ol>

												<p>
													Rice's theorem states that if <b>P's</b> property meets these two conditions, then <b>P</b> is an undecidable language.
												</p>

											</div>
											<p>

											</p>
											<p>
												Another way to understand Rice's theorem in the context of programming languages is that it is impossible to devise a decider for programs with a particular nontrivial <b>semantic/behavioral</b> property, ignoring the actual syntax of the programs that have this property.  So we see, for example, that Rice's theorem applies to <b>E<SUB>TM</SUB></b> and <b>Reg<SUB>TM</SUB></b>, but Rice's theorem <b>does not apply</b> to <b>TwoWrite<SUB>TM</SUB></b>, since there are certainly ways to implement the same recognizer for a language without using a second tape, as we explained in the multitape to single tape reduction in class.  Still, it could have saved us work on <b>E<SUB>TM</SUB></b> and <b>Reg<SUB>TM</SUB></b>.
											</p>
											<p>
												<b>Proof of Rice's Theorem: </b> Let's assume the language <b>P</b> satisfying these two conditions is decidable.  We have to somehow use the nontrivial and semantic properties of its language to create a decider for <b>A<SUB>TM</SUB></b>.  Since it's nontrivial, we can assume there is at least one machine <b>T</b> whose encoding is in <b>P</b>, and at least one machine <b>F</b> whose encoding is not in <b>P</b>.  Let's create the following auxiliary machine
											</p>


											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def P_M_w(s):
													if M accepts w:
														if T Accepts s: # T can be any machine not in P
														# We know there must exist at least one such machine by property 1.
														# Notice how we're also implicitly using property 2
														# by only looking at whether T accepts s
															Accept
														else:
															Reject
													else:
														if F accepts s:
															# F can be any machine *not* in P
															# We know there must exist at least one such machine by property 1.
															Accept
														else:
															Reject
											</script>

											<p>
												Now let's let the machine <b>M<SUB>P</SUB></b> be a decider for our assumed decidable language <b>P</b>.  Then the following machine decides <b>A<SUB>TM</SUB></b>
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def ATM(<M, w>):
													if MP(<P_M_w>) Accepts:
														Accept
													else:
														Reject
											</script>

											<p>
												We've setup our auxiliary machine <b>P_M_w</b> to act like a machine in <b>P</b> if and only if <b>M</b> accepts <b>w</b>.  Otherwise, it acts like a machine not in <b>P</b>.  Therefore, <b>M<SUB>p</SUB></b> accepts <b>P_M_w</b> if and only if <b>M</b> accepts <b>w</b>.  Therefore, we have created a decider for <b>A<SUB>TM</SUB></b>, which is a contradiction, showing that <b>P</b> is undecidable.  This completes the proof.
											</p>

											<p>
												We can see that some of the above examples use this logic directly.  For instance, <a href = "#regtm"><b>Reg<SUB>TM</SUB></b></a> creates an auxiliary machine that acts like DFA if <b>M</b> accepts <b>w</b>, but which otherwise acts like a CFG, which is not in <b>Reg<SUB>TM</SUB></b>.  But now we don't have to think so hard, and we just have to convince ourselves that there is at least one machine in the language and at least one machine not in the language, and that this property is a semantic property.
											</p>

											

                                    
										<HR>
											<h2><a name = "unrecognizable">Co-Recognizable And Unrecognizable Languages</a></h2>

											<p>There's one more thing worth mentioning about undecidable languages: they don't play nicely with complements.</p>

											
											<p>
												A language is called <b>co-recognizable</b> if its complement is recognizable.  We can prove the following theorem about decidable languages:
											</p>

											<div style="background-color: blanchedalmond; padding:10px;">
											
											<h4>Theorem: Recognizable/Co-Recognizable Languages</h4>
												<p>A language is decidable if and only if it is both Turing recognizable and Turing co-recognizable.</p>
											</div>
											<p></p>
											<p>
												<b>Proof: </b> Let's prove the first direction: that if a language is decidable, then it is recognizable and co-recognizable.  We already know that if a language is decidable, then it's recognizable (since decidability is a stronger condition that rules out infinite loops).  To show that it's also co-recognizable, we simply flip the Accept/Reject states, which we can safely do because there are no infinite loops.
											</p>

											<p>
												Let's now prove the other direction: that if a language is both recognizable and co-recognizable, then it is decidable.  In this case, we can assume that we have machines <b>M<SUB>L</SUB></b> and <b>M<SUB>C</SUB></b> that recognize a language and its complement, respectively.  So we'll run <b>M<SUB>L</SUB></b> and <b>M<SUB>C</SUB></b> in parallel.  If <b>M<SUB>L</SUB></b> accepts, then we accept.  If <b>M<SUB>C</SUB></b> accepts, then we reject (since if a string is in the complement, it should not be in our language).  Since these are both recognizers and they accept the opposite of each other, exactly one of them will accept eventually, even if the other loops infinitely.  So we have a valid decider.  This completes the proof.
											</p>

											<p>
												This theorem tells us that complements play nicely with decidable languages, but they may not with undecidable languages.  
											</p>

											<h3><a name = "cATM">The complement of A<SUB>TM</SUB> Is Not Even Recognizable</a></h3>

											<p>
												<b>Proof: </b> Suppose by contradiction that the complement of <b>A<SUB>TM</SUB></b> is recognizable.  Then both <b>A<SUB>TM</SUB></b> and its complement are recognizable, so by the above theorem, <b>A<SUB>TM</SUB></b> must be decidable.  But the very first thing we talked about in these notes is that <a href = "#atm">A<SUB>TM</SUB></a> is not decidable.  Therefore, the complement of <b>A<SUB>TM</SUB></b> must not even be recognizable!  This completes the proof.
											</p>

											<p>
												But wait, you may be saying!  I can create a recognizer for the complement of <b>A<SUB>TM</SUB></b> using a recognizer <b>A</b> for <B>A<SUB>TM</SUB></B> as follows
											</p>

											<script type="syntaxhighlighter" class="brush: python"><![CDATA[
												def coATM(<M, w>):
													if A(<M, w>) Accepts:
														Reject
													else:
														Accept
											</script>

											<p>
												Doesn't this recognize the complement of <b>A<SUB>TM</SUB></b>?  Well, in order to recognize a language, we have to always be able to get to an accept state without infinitely looping.  However, if <b>A</b> does not accept <b>w</b>, it may infinitely loop on it.  So we might never get past the first if statement.  This is intuitively why the complement of <b>A<SUB>TM</SUB></b> is not recognizable (but again, we need the rigorous proof above to rule out all ways of being clever).
											</p>

                                </div>
						</div>
					</div>

					<!--LaTeX in Javascript!-->
					<script src="../../../../jsMath/easy/load.js"></script>
					<!--Syntax highlighting in Javascript!-->
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shCore.js"></script>
					<script type="text/javascript" src="../../../syntaxhighlighter/scripts/shBrushJScript.js"></script>
                    <script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushCpp.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushXml.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushMatlabSimple.js"></script>
					<script type="text/javascript" src="../../../../syntaxhighlighter/scripts/shBrushPython.js"></script>
					<link type="text/css" rel="stylesheet" href="../../../../syntaxhighlighter/styles/shCoreDefault.css"/>
					<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">
							<!-- Menu -->
								<nav id="menu">
									<header class="major">
										<h2>Menu</h2>
									</header>
									<ul>
                                        <li>
											<span class="opener">General</span>
											<ul>
												<li><a href = "../../index.html#overview">Overview</a></li>
												<li><a href = "../../index.html#logistics">Technology Logistics</a></li>
												<li><a href = "../../index.html#readings">Readings</a></li>
												<li><a href = "../../index.html#deliverables">Deliverables</a></li>
												<li><a href = "../../index.html#schedule">Schedule</a></li>
												<li><a href = "../../index.html#grading">Grading</a></li>
												<li><a href = "../../index.html#environment">Classroom Environment</a></li>
												<li><a href = "../../index.html#collaboration">Collaboration Policy</a></li>
												<li><a href = "../../index.html#other">Other Resources / Policies</a></li>
											</ul> 
										</li>
										<li><a href = "../../Software/index.html">Software</a></li>
										<li><a href = "../../index.html#schedule">Schedule</a></li>
										<li><a href = "../../FinalProject/index.html">Final Project</a></li>
                                        <li>
											<span class="opener">Assignments</span>
											<ul>
												<li>
													<a href = "../../Assignments/HW1_Discrete/index.html">HW1: Discrete Math Practice</a>
												</li>
												<li>
													<a href = "../../Assignments/HW2_DFA/index.html">HW2: DFAs</a>
												</li>
												<li>
													<a href = "../../Assignments/HW3_NFA/index.html">HW3: DFAs And NFAs</a>
												</li>
												<li>
													<a href = "../../Assignments/HW4_Regexp/index.html">HW4: Regular Expressions And Nonregular Languages</a>
												</li>
												<li>
													<a href = "../../Assignments/HW5_CFGs/index.html">HW5: Context Free Grammars And Pushdown Automata</a>
												</li>
												<li>
													<a href = "../../Assignments/HW6_Turing/index.html">HW6: Turing Machines</a>
												</li>
												<li>
													<a href = "../../Assignments/HW7_Turing2/index.html">HW7: Turing Machines, Turing Enumerators, And Decidability</a>
												</li>
												<li>
													<a href = "../../Assignments/HW8_Decidability/index.html">HW8: Decidability</a>
												</li>
												<li>
													<a href = "../../Assignments/HW9_Computability/index.html">HW9: Computability</a>
												</li>
											</ul>
										</li>
                                        <li>
											<span class="opener">Class Exercises</span>
											<ul>
												<li><a href = "../../ClassExercises/Week1_Unplugged">Week 1: Acting Out DFAs</a></li>
												<li><a href = "../../ClassExercises/Week1_Discrete">Week 1: Discrete Math Review</a></li>
												<li><a href = "../../ClassExercises/Week1_FridayDFABinary">Week 1: Binary And JFLAP</a>
													<ul>
														<li><a href = "../../ClassExercises/Week1_FridayDFABinary/index.html#binary">Binary Drills</a></li>
														<li><a href = "../../ClassExercises/Week1_FridayDFABinary/index.html#jflap">JFLAP Exercises</a></li>
													</ul>
												</li>
												<li><a href = "../../ClassExercises/Week2_Formal">Week 2: Formal Description of DFAs, Divisibility</a>
													<ul>
														<li>
															<a href = "../../ClassExercises/Week2_Formal/index.html#formalcode">Formal Regular Languages: Code</a>
														</li>
													</ul>
												</li>
												<li><a href = "../../ClassExercises/Week2_Union">Week 2: Union of Regular Languages</a></li>
												<li><a href = "../../ClassExercises/Week3_NFAs">Week 3: Nondeterministic Finite Automata (NFAs), Reversing Regular Languages</a></li>
												<li><a href = "../../ClassExercises/Week3_NFAToDFA">Week 3: NFAs Recognize Regular Languages (i.e. NFAs To DFAS)</a></li>
												<li><a href = "../../ClassExercises/Week4_NFACode">Week 4: Efficiently Evaluating NFAs in Python with and without Lambda</a></li>
												<li><a href = "../../ClassExercises/Week4_DFAToRegexp">Week 4: Converting Regular Expressions To DFAs And Back</a></li>
												<li><a href = "../../ClassExercises/Week4_Grep">Week 4: Grep: Regular Expression Parsing And Evaluating</a></li>
												<li><a href = "../../ClassExercises/Week5_PumpingLemma">Week 5: The Pumping Lemma</a></li>
												<li><a href = "../../ClassExercises/Week7_Turing">Week 7/8: Turing Machine Examples</a></li>
												<li><a href = "../../ClassExercises/Week8_MultitapeTuring">Week 8: Multitape Turing Machine Examples</a></li>
												<li><a href = "../../ClassExercises/Week10_Decidability">Week 10: Decidability</a></li>
												<li><a href = "../../ClassExercises/Week11_Infinities">Week 11: Countable And Uncountable Infinities</a></li>
												<li><a href = "../../ClassExercises/Week12_Undecidability">Week 12: Undecidability</a></li>
												<li><a href = "../../ClassExercises/Week13_Modules/video1.html">Week 13: The Class P</a></li>
												<li><a href = "../../ClassExercises/Week13_Modules/video2.html">Week 13: The Class NP</a></li>
												<li><a href = "../../ClassExercises/Week14_CookLevin">Week 14: Cook Levin Theorem And SAT Solving</a></li>
											</ul>
										</li>
									</ul>
								</nav>


							<!-- Footer -->
								<footer id="footer">
									<p class="copyright">&copy; <a href = "http://www.ctralie.com">Christopher J. Tralie</a>. All rights reserved.  Contact chris.tralie@gmail.com. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
								</footer>

						</div>
					</div>

			</div>
			
            <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- End Sidebar !-->

<!-- Scripts -->
			<script src="../../assets/js/jquery.min.js"></script>
			<script src="../../assets/js/skel.min.js"></script>
			<script src="../../assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="../../assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="../../assets/js/main.js"></script>
<!-- End Scripts -->
